#!/usr/bin/perl -T 
#################################################################################
#
# Copyright (c) 2013 Genome Research Ltd.
# 
# Author: Joshua C. Randall <jcrandall@alum.mit.edu>
# 
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <http://www.gnu.org/licenses/>.
# 
#################################################################################

package lustre_operator;

=head1 NAME

lustre_operator - a wrapper script for Lustre's 
lfs command suitable for sudo use.

=head1 GENERAL

=head2 SYNOPSIS

lustre_operator B<lustre_mount_point> B<command> [B<options>]

Supports the C<quota>, C<setquota>, and C<find> lfs commands.

=head2 ARGUMENTS

=over

=item B<lustre_mount_point>

An absolute path to the lustre filesystem mount point, as specified 
in F</proc/mounts> and/or F</etc/mtab> (and reported by I<mount>).

=item B<command>

Command (C<quota>, C<setquota>, or C<find>) to run.

=back

=head2 OPTIONS

=over

=item [--help|-?]

=back

=head1 QUOTA

=head2 SYNOPSIS

lustre_operator B<lustre_mount_point> quota [B<options>]

=head2 OPTIONS

=over

=item [<-u|-g> <uname>|<uid>|<gname>|<gid>] 

=item [-q]

=item [-v]

=item [-o <obd_uuid>]

=back

=head2 EXAMPLES

=over

=item get quota information for the current user and group on /mnt/lustre1:

C<lustre_operator /mnt/lustre1 quota>

=item get quota information for user1 on /mnt/lustre1:

C<lustre_operator /mnt/lustre1 quota --user user1>

=item get quota information for group1 on /mnt/lustre1:

C<lustre_operator /mnt/lustre1 quota --group group1>

=back

=head1 SETQUOTA

=head2 SYNOPSIS

lustre_operator B<lustre_mount_point> setquota 
-u|--user|-g|--group <uname>|<uid>|<gname>|<gid> [options]

=head2 OPTIONS

=over

=item -u|--user|-g|--group <uname>|<uid>|<gname>|<gid>

Specify user or group by either name or number. 

=back

=head2 OPTIONS

=over

=item [--size-softlimit|-b <size-softlimit>] 

=item [--force-size-softlimit]

=item [--size-hardlimit|-B <size-hardlimit>]

=item [--force-size-hardlimit]

=item [--inode-softlimit|-i <inode-softlimit>]

=item [--force-inode-softlimit]

=item [--inode-hardlimit|-I <inode-hardlimit>]

=item [--force-inode-hardlimit]

=back

=head2 EXAMPLES

=over

=item set the quota for user user2 on /mnt/lustre2 to 1 TebiByte 
(1024^4 bytes) and 1 million inodes (files):

C<lustre_operator /mnt/lustre1 setquota --user user2 
--size-hardlimit 1TiB  --inode-hardlimit 1M>

=item set the quota for group group2 on /mnt/lustre2 to 100 megabytes 
(100 * 1000^2 bytes) and 1500 inodes:

C<lustre_operator /mnt/lustre2 setquota --group group2 
--size-hardlimit 100MB --inode-hardlimit 1.5k>

=item set the quota for group group2 on /mnt/lustre2 to 1 block and 
1 inode (this is the minimum quota):

C<lustre_operator /mnt/lustre2 setquota --group group2 
--size-hardlimit 1 --inode-hardlimit 1>

=back

=head1 FIND

=head2 SYNOPSIS

lustre_operator B<lustre_mount_point> find B<dir|file> [options]

=head2 ARGUMENTS

=over

=item B<dir|file>

Path from which to begin the recursive find.

=back

=head2 OPTIONS

=over

=item [[!] --atime|-A [+-]N]

=item [[!] --mtime|-M [+-]N]

=item [[!] --ctime|-C [+-]N]

=item [--maxdepth|-D N]

=item [[!] --name|-n <pattern>]

=item [--print0|-P]

=item [--print|-p]

=item [[!] --obd|-O <uuid[s]>]

=item [[!] --size|-s [+-]N[bkMGTP]]

=item [[!] --type|-t <filetype>]

=item [[!] --gid|-g|--group|-G <gid>|<gname>]

=item [[!] --uid|-u|--user|-U <uid>|<uname>]

=back

=head3 NOTES

=over

=item !: used before an option indicates 'NOT' the requested attribute

=item -: used before an value indicates 'AT MOST' the requested value

=item +: used before an option indicates 'AT LEAST' the requested value

=back

=head2 EXAMPLES

=over 

=item find all files named F<*file*> under /mnt/lustre/dir3:

C<lustre_operator /mnt/lustre3 find /mnt/lustre3/dir3 --name \*file\*>

=back

=cut



use strict;
use warnings;
use 5.008_008;

#################################################################################
# In taint mode, '.' is removed from @INC and PERL5LIB is ignored so we can 
# safely depend on only getting modules from directories compiled into perl
# (see http://perldoc.perl.org/perlsec.html#Taint-mode-and-@INC)
#################################################################################
use Getopt::Long qw(:config posix_default no_ignore_case auto_version auto_help);
use Pod::Usage;


use Config;

#################################################################################
# Configuration
#################################################################################
# absolute path to the lfs binary
my $LFS_BIN 	       = "/usr/bin/lfs";
# the block size that Lustre uses for quota (in Bytes)
my $LFS_BLOCKSIZE      = 1024; 
my $TIMER_INACTIVE     = "inactive";
my $NO_QUOTA	       = "unlimited";
# regular expression matching illegal filename/path characters
my $ILLEGAL_PATH_REGEX = qr/[\|\\\012\r\n\t\013\*\"\?\<\:\>]/; 


#################################################################################
# Process command-line
#################################################################################
my $lustre_mount_point = shift or error_exit_usage("Must specify lustre_mount_point as first argument", "GENERAL");

my $lfs_cmd = shift or error_exit_usage("Must specify quota, setquota, or find as second argument");

$lfs_cmd =~ m/^(quota|setquota|find)$/ or error_exit_usage("Unrecognized command: $lfs_cmd");

# verify that lustre_mount_point is listed in /proc/mounts or /etc/mtab (and untaint)
$lustre_mount_point = valid_lustre_mount_point($lustre_mount_point) or error_exit("Invalid lustre filesystem $lustre_mount_point, must specify absolute path to lustre mount point (as listed in /proc/mounts or /etc/mtab)");

my @lfs_args;

if ($lfs_cmd eq "quota") {
    # quota: Display disk usage and limits.

    push @lfs_args, "quota";


    my $arg = shift;
    while (defined($arg)) {
	if ($arg =~ m/^(-u|--user|-g|--group)$/) {
	    my $uorg = $1;
	    $uorg =~ s/^--user$/-u/;
	    $uorg =~ s/^--group$/-g/;
	    my $userorgroup = shift;
	    $userorgroup =~ m/^([0-9]+|[a-z_][a-z0-9_-]{0,31})$/ or error_exit("$uorg must be followed by <uname>|<uid>|<gname>|<gid> ($userorgroup not valid)");
	    $userorgroup = $1;
	    push @lfs_args, $uorg, $userorgroup;
	} elsif ($arg =~ m/^(-q|-v)$/) {
	    $arg = $1;
	    push @lfs_args, $arg;
	} else {
	    error_exit("option $arg not supported by wrapper");
	}
	$arg = shift;
    }
    push @lfs_args, $lustre_mount_point;
} elsif ($lfs_cmd eq "setquota") {
    my $force_block_hardlimit = 0;
    my $force_block_softlimit = 0;
    my $force_inode_hardlimit = 0;
    my $force_inode_softlimit = 0;

    push @lfs_args, "setquota";

    my $uorg = shift or error_exit_usage("Must specify one of -u|--user|-g|--group as first argument after setquota");
    $uorg =~ m/^(-u|--user|-g|--group)$/ or error_exit_usage("First argument must be one of -u|--user|-g|--group");
    $uorg = $1;
    $uorg =~ s/^--user$/-u/;
    $uorg =~ s/^--group$/-g/;
    
    my $userorgroup = shift or error_exit_usage("$uorg must be followed by <uname>|<uid>|<gname>|<gid>");
    $userorgroup =~ m/^([0-9]+|[a-z_][a-z0-9_-]{0,31})$/ or error_exit("$uorg must be followed by valid <uname>|<uid>|<gname>|<gid> ($userorgroup not valid)");
    $userorgroup = $1;
    
    push @lfs_args, $uorg, $userorgroup;
    
    my $arg = shift;
    my %newquota;
    while (defined($arg)) {
	if ($arg =~ m/^(-b|--size-softlimit)$/) {
	    my $bsl = shift;
	    defined($bsl) or error_exit_usage("Must specify size-softlimit after [-b|--size-softlimit]");
	    $bsl =~ m/^([0-9.]+[bkmgtp]?)$/ or error_exit("size-softlimit $bsl not valid");
	    $bsl = $1;
	    push @lfs_args, "--size-softlimit", $bsl;
	    $newquota{"block-softlimit"} = $bsl;
	} elsif ($arg =~ m/^(-B|--size-hardlimit)$/) {
	    my $bhl = shift;
	    defined($bhl) or error_exit_usage("Must specify size-hardlimit after [-B|--size-hardlimit]");
	    $bhl =~ m/^([0-9.]+[bkmgtp]?)$/ or error_exit("size-hardlimit $bhl not valid");
	    $bhl = $1;
	    push @lfs_args, "--size-hardlimit", $bhl;
	    $newquota{"block-hardlimit"} = $bhl;
	} elsif ($arg =~ m/^(-i|--inode-softlimit)$/) {
	    my $isl = shift;
	    defined($isl) or error_exit_usage("Must specify inode-softlimit after [-i|--inode-softlimit]");
	    $isl =~ m/^([0-9.]+)$/ or error_exit("inode-softlimit $isl not valid");
	    $isl = $1;
	    push @lfs_args, "--inode-softlimit", $isl;
	    $newquota{"inode-softlimit"} = $isl;
	} elsif ($arg =~ m/^(-I|--inode-hardlimit)$/) {
	    my $ihl = shift;
	    defined($ihl) or error_exit_usage("Must specify inode-hardlimit after [-I|--inode-hardlimit]");
	    $ihl =~ m/^([0-9.]+)$/ or error_exit("inode-hardlimit $ihl not valid");
	    $ihl = $1;
	    push @lfs_args, "--inode-hardlimit", $ihl;
	    $newquota{"inode-hardlimit"} = $ihl;
	} elsif ($arg =~ m/^(--force-size-hardlimit)$/) {
	    $force_block_hardlimit = 1;
	} elsif ($arg =~ m/^(--force-size-softlimit)$/) {
	    $force_block_softlimit = 1;
	} elsif ($arg =~ m/^(--force-inode-hardlimit)$/) {
	    $force_inode_hardlimit = 1;
	} elsif ($arg =~ m/^(--force-inode-softlimit)$/) {
	    $force_inode_softlimit = 1;
	} else {
	    error_exit_usage("unrecognised setquota argument $arg");
	}
	$arg = shift;
    }
    if (@lfs_args <= 3) {
	error_exit("no limits specified, nothing to do.");
    }
    push @lfs_args, $lustre_mount_point;
    
    # always check quota before setting and report old quota to user
    my %existingquota = get_quota($lustre_mount_point, $uorg, $userorgroup);
#          'size-grace' => '-',
#          'size-hardlimit' => 'none',
#          'inode-softlimit' => 'none',
#          'size-used' => '2734402884',
#          'inode-hardlimit' => 'none',
#          'inode-grace' => 'none',
#          'size-softlimit' => 'none',
#          'inode-used' => '135738'

    # check proposed quotas against existing usage
    if ( !$force_block_hardlimit &&
	 !over_quota($existingquota{"block-hardlimit"}, $existingquota{"block-used"}) &&
	 over_quota($newquota{"block-hardlimit"}, $existingquota{"block-used"}) ) {
	error_exit("change would put size-hardlimit over quota, refusing without --force-size-hardlimit");
    }

    if ( !$force_block_softlimit &&
	 !over_quota($existingquota{"block-softlimit"}, $existingquota{"block-used"}) &&
	 over_quota($newquota{"block-softlimit"}, $existingquota{"block-used"}) ) {
	error_exit("change would put size-softlimit over quota, refusing without --force-size-softlimit");
    }

    if ( !$force_inode_hardlimit &&
	 !over_quota($existingquota{"inode-hardlimit"}, $existingquota{"inode-used"}) &&
	 over_quota($newquota{"inode-hardlimit"}, $existingquota{"inode-used"}) ) {
	error_exit("change would put inode-hardlimit over quota, refusing without --force-inode-hardlimit");
    }

    if ( !$force_inode_softlimit &&
	 !over_quota($existingquota{"inode-softlimit"}, $existingquota{"inode-used"}) &&
	 over_quota($newquota{"inode-softlimit"}, $existingquota{"inode-used"}) ) {
	error_exit("change would put inode-softlimit over quota, refusing without --force-inode-softlimit");
    }
    
} elsif ($lfs_cmd eq "find") {
    push @lfs_args, "find";
    my $matchpat = 0;

    # stat the mount point to get the dev_t for the filesystem (to check each <dir|file> entry against)
    (my $fs_dev, undef) = stat $lustre_mount_point or error_exit("could not stat mount point $lustre_mount_point");
    
    # the first arguments (until the first ! or -) must start with $lustre_mount_point
    while (!$matchpat) {
	my $dirorfile = shift;
	if (!defined($dirorfile) || $dirorfile =~ m/^[-!]/) {
	    # have an argument staring with '!' or '-' (or no argument)
	    $matchpat = 1;
	    unshift @ARGV, $dirorfile;
	} else {
            $dirorfile =~ m/^($lustre_mount_point.*)$/ or error_exit("<dir|file> $dirorfile must begin with $lustre_mount_point");
	    $dirorfile = $1;
	    # -f and -d will follow symlinks (as does `lfs find`)
	    ( -f $dirorfile || -d $dirorfile ) or error_exit("$dirorfile is not a plain file or directory");
	    # stat also follows symlinks, so in case of symlinks it is the target stats that we will get
	    (my $dirorfile_dev, undef) = stat $dirorfile or error_exit("could not stat <dir|file> $dirorfile");
	    ($dirorfile_dev == $fs_dev) or error_exit("$dirorfile and $lustre_mount_point are not on the same device ($dirorfile is on device $dirorfile_dev but $lustre_mount_point is on device $fs_dev)");
	    push @lfs_args, $dirorfile;
	}
    } 
    (@lfs_args > 0) or error_exit("must specify <dir|file> before match paramters");
    # now we should be in match parameters section 
    my $arg = shift;
    while (defined($arg)) {
	if ($arg =~ m/^[!]$/) {
	    push @lfs_args, '!';
	} elsif ($arg =~ m/^(--{0,1}[a-zA-Z]{1,})$/) {
	    $arg = $1;
	    if ($arg =~ m/^(--print0{0,1}|-[pP])$/) {
		# have one of the args that does not require a parameter
		push @lfs_args, $arg;
	    } else {
		# option requires a parameter
		my $param = shift;
		# check param syntax depending on value of arg
		if ($arg =~ m/^-(-(atime|mtime|ctime)|[AMC])$/) {
		    # [+-]N
		    $param =~ m/^([-+]{0,1}[0-9]+)$/ or error_exit("parameter after $arg was not [+-]N ($param)");
		    $param = $1;
		} elsif ($arg =~ m/^-(-(maxdepth)|[D])$/) {
		    # N
		    $param =~ m/^([0-9]+)$/ or error_exit("parameter after $arg was not numeric ($param)");
		    $param = $1;
		} elsif ($arg =~ m/^-(-(size)|[s])$/) {
		    # [+-]N[bkMGTP]
		    $param =~ m/^([-+]{0,1}[0-9]+[bkMGTP]{0,1})$/ or error_exit("parameter after $arg was not [+-]N[bkMGTP] ($param)");
		    $param = $1;
		} elsif ($arg =~ m/^-(-(name)|[n])$/) {
		    # <pattern>
		    $param =~ m/^([^\/]+)$/ or error_exit("parameter after $arg contained a '/' ($param)");
		    $param = $1;
		} elsif ($arg =~ m/^-(-(obd)|[O])$/) {
		    # <uuid[s]>
		    $param =~ m/^([-_,[:alnum:]]+)$/ or error_exit("parameter after $arg was not <uuid[s]> ($param)");
		    $param = $1;
		} elsif ($arg =~ m/^-(-(type)|[t])$/) {
		    # <filetype> == [bcdpflsD]
		    $param =~ m/^([bcdpflsD])$/ or error_exit("parameter after $arg was not [bcdpflsD] ($param)");
		    $param = $1;
		} elsif ($arg =~ m/^-(-(uid|user|gid|group)|[uUgG])$/) {
		    # <gid>|<gname>|<uid>|<uname>
		    $param =~ m/^([0-9]+|[a-z_][a-z0-9_-]{0,15})$/ or error_exit("parameter after $arg was not <gid>|<gname>|<uid>|<uname> ($param)");
		    $param = $1;
		} else {
		    error_exit("unsupported find argument $arg");
		}
		push @lfs_args, $arg;
		push @lfs_args, $param;
	    }
	} else {
	    error_exit("invalid find argument $arg");
	}
	$arg = shift;
    }
} else {
    error_exit("lfs command $lfs_cmd not supported by this wrapper script (supported commands are: quota, setquota, find)");
}


# if we have not exited yet, we are ok to execute lfs using the args in @lfs_args
if (@lfs_args > 0) {
    exec_lfs(@lfs_args);
} else {
    error_exit("no arguments for $LFS_BIN");
}

sub exec_lfs {
    my @lfs_args = @_;

    # completely squash environment before exec
    %ENV = ();

    # call exec and never return (unless command is not found)
    exec { $LFS_BIN } $LFS_BIN, @lfs_args or error_exit("couldn't exec $LFS_BIN");
}

sub get_quota {
    my $lustre_mount_point = shift;
    my $uorg = shift;
    my $userorgroup = shift;

    # return quota data in hash
    my %quota;
    
    # this code adapted from "safe pipe open for reading" 
    # described in: http://perldoc.perl.org/perlipc.html#Safe-Pipe-Opens
    my $pid = open(CHILD_STDOUT, "-|");
    defined($pid) or error_exit("can't fork: $!");
    
    if (!$pid) { # $pid is only set in parent
	# child, call exec and never return (exec_lfs will exit on error)
	exec_lfs("quota", $uorg, $userorgroup, $lustre_mount_point);
	# as a safety precaution, force child to exit (this should never be reached)
	error_exit("child process attempted to continue after exec_lfs");
    } else { 
        # parent, process data from child
	my $usergroupline = <CHILD_STDOUT>;
	chomp $usergroupline;
	my $usergroupname = "";
	my $ugid = -1;
	if ($uorg eq '-u') {
	    $usergroupline =~ m/user\s(\S+)/ or error_exit("could not find user in lfs quota output");
	    $usergroupname = $1;
	    $usergroupline =~ m/uid\s([0-9]+)/ or error_exit("could not find uid in lfs quota output");
	    $ugid = $1;
	} elsif ($uorg eq '-g') {
	    $usergroupline =~ m/group\s(\S+)/ or error_exit("could not find group in lfs quota output");
	    $usergroupname = $1;
	    $usergroupline =~ m/gid\s([0-9]+)/ or error_exit("could not find gid in lfs quota output");
	    $ugid = $1;
	} else {
	    error_exit("invalid uorg $uorg in quotacheck");
	}

	my $headerline = <CHILD_STDOUT>;
	chomp $headerline;
	$headerline =~ m/kbytes\s+quota\s+limit\s+grace\s+files\s+quota\s+limit\s+grace\s*$/ or error_exit("unexpected header in output from lfs quota");

	my $fsline = <CHILD_STDOUT>;
	chomp $fsline;
	$fsline =~ m/^\s*$lustre_mount_point\s*$/ or error_exit("unexpected filesystem reported from lfs quota: $fsline (expecting: $lustre_mount_point)");

	my $quotaline = <CHILD_STDOUT>;
	chomp $quotaline;
	$quotaline =~ m/([0-9-]+)\s+([0-9-]+)\s+([0-9-]+)\s+(\S+)\s+([0-9-]+)\s+([0-9-]+)\s+([0-9-]+)\s+(\S+)\s*$/ or error_exit("unexpected data in output from lfs quota: $quotaline");
	$quota{"block-used"} = $1;
	$quota{"block-softlimit"} = $2;
	$quota{"block-hardlimit"} = $3;
	$quota{"block-grace"} = $4;
	$quota{"inode-used"} = $5; 
	$quota{"inode-softlimit"} = $6;
	$quota{"inode-hardlimit"} = $7;
	$quota{"inode-grace"} = $8;

	foreach my $key ("size-grace", "inode-grace") {
	    $quota{$key} =~ s/^-$/$TIMER_INACTIVE/;
	}

	foreach my $key ("block-softlimit", "block-hardlimit", "inode-softlimit", "inode-hardlimit") {
	    $quota{$key} =~ s/^0$/$NO_QUOTA/;
	}

	while(my $emptyline = <CHILD_STDOUT>) {
	    chomp $emptyline;
	    $emptyline =~ m/^\s*$/ or error_exit("unexpected additional output from lfs quota: $emptyline");
	}
	
	close(CHILD_STDOUT) or error_exit("child process exited: $!");
    }

    # only parent should reach this point, return quota
    return %quota;
}


sub valid_lustre_mount_point {
    my $lustre_mount_point = shift;
    my $validated_mount_point = undef;

    if ( valid_path($lustre_mount_point) ) {
	# have valid path based on regex, check for it in /proc/mounts or /etc/mtab
	my $mfile = "/proc/mounts";
	if (! open MOUNTS, "<$mfile" ) {
	    $mfile = "/etc/mtab";
	    open MOUNTS, "<$mfile" or error_exit("could not open /proc/mounts or /etc/mtab for reading");
	}
	MOUNTLINE: while( my $mountline = <MOUNTS> ) {
	    chomp $mountline;
	    my ($spec, $mountpoint, $type, undef) = split /\s+/, $mountline, 4;
	    if ($mountpoint eq $lustre_mount_point) {
		if ($type eq "lustre") {
		    # validated, untaint
		    $mountpoint =~ m/^(\/.*)$/ or error_exit("did not have absolute path as mount point: $mountpoint");
		    $validated_mount_point = $1;
		    last MOUNTLINE;
		} else {
		    error_exit("$lustre_mount_point was listed in $mfile but was not of type lustre");
		}
	    }
	}
	close MOUNTS;
    }
    return $validated_mount_point;
}


sub valid_path {
    my $filepath = shift;
    $filepath !~ /$ILLEGAL_PATH_REGEX/ ? 1 : undef;
}


sub over_quota {
    my $quota = shift || $NO_QUOTA;
    my $used = shift or error_exit("over_quota called without used value");

    $quota =~ m/^($NO_QUOTA|[0-9]+)$/ or error_exit("quota [$quota] was neither $NO_QUOTA nor an integer");

    if (($quota eq $NO_QUOTA) ||
	($quota >= $used)) {
	# not over quota
	return undef;
    } 
    
    # over quota
    return 1;
}

sub error_exit {
    my $message = shift;
    die "Error: $message\n";
}

sub error_exit_usage {
    my $message = shift;
    my $command = shift;
    
    my $sections = [ qw(SYNOPSIS ARGUMENTS OPTIONS) ];
    if ($command) {
	$sections = [ "$command/SYNOPSIS", "$command/ARGUMENTS", "$command/OPTIONS" ];
    }

    pod2usage({
	-noperldoc => 1,
	-message => "Error: $message\n",
	-exitval => 1,
	-verbose => 99,
	-sections => $sections,
	      });

    # this should not be reached, but call it in case something goes wrong with pod2usage
    error_exit($message);
}




package lustre_operator;

__END__

=head1 DESCRIPTION

A wrapper script for portions of the I<lfs> command distributed with the
Lustre filesystem (L<http://lustre.org/>). Currently wraps up the functionality
of the quota, setquota, and find commands.

It takes as its first argument the mount point of a Lustre filesystem and
will only allow lfs commands to run against that filesystem. It is intended
with use along with sudo, as the sudoers file can specify that individual
users or groups can run this wrapper script against a limited set of Lustre
filesystems specifically listed.


=head1 CONFIGURATION AND ENVIRONMENT

This script is intended to be called using sudo, so for security reasons it 
does not have any external configuration files or environment variables.

In fact, it does not allow dependencies to be loaded from F<.> or from a 
PERL5LIB directory, and when calling lfs it eliminates all environment 
variables. 

You can configure Lustre operators to be able to run this command as root by 
adding an appropriate line to the F</etc/sudoers> file listing the full path 
to this script followed by the mount point of the Lustre file system for 
which they are allowed to run it.

For example:
C<user1 ALL = (root) NOPASSWD : /usr/local/bin/lustre_operator /mnt/lustre1, \
                              /usr/local/bin/lustre_operator /mnt/lustre2>


=head1 DEPENDENCIES

=over 

=item Lustre I<lfs> command 

=item L<Getopt::Long> (from CPAN)

=item L<Pod::Usage> (from CPAN)

=back


=head1 INCOMPATIBILITIES

May not work with older versions of the lfs command (Lustre < 1.8), as
this has not been tested. 


=head1 BUGS AND LIMITATIONS

There are no known bugs in this program. 

Please report problems to L<mailto:hgi@sanger.ac.uk>

Patches are welcome. 


=head1 AUTHOR

Joshua C. Randall (jcrandall@alum.mit.edu)


=head1 LICENCE AND COPYRIGHT

Copyright (c) 2013 Genome Research Ltd.

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along with
this program. If not, see <http://www.gnu.org/licenses/>.

=cut

