#!/usr/bin/perl -T 
#################################################################################
#
# Copyright (c) 2013 Genome Research Ltd.
# 
# Author: Joshua C. Randall <jcrandall@alum.mit.edu>
# 
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <http://www.gnu.org/licenses/>.
# 
#################################################################################

use strict;
use warnings;
use 5.008_008;

package lustre_operator;


#################################################################################
# In taint mode, '.' is removed from @INC and PERL5LIB is ignored so we can 
# safely depend on only getting modules from only directories compiled into perl
# (see http://perldoc.perl.org/perlsec.html#Taint-mode-and-@INC)
# 
# This means all of the below modules MUST be located in the system PERL5LIB --
# this is intentional for the security of this script. 
#################################################################################
use Getopt::Long qw(GetOptionsFromArray :config posix_default no_ignore_case);
use Pod::Usage;
use DateTime;
use List::Util qw(min);
use JSON::XS;
use Data::Dumper;

#################################################################################
# Configuration
#################################################################################

# the block size that Lustre uses to set and report quota (in Bytes)
my $LFS_BLOCKSIZE      = 1024; 

# the value lfs reports when quota grace time is not active (e.g. not over soft)
my $LFS_GRACE_INACTIVE = "-";

# the value lfs reports when size quota is unlimited
my $LFS_QUOTA_SIZE_UNLIMITED = 0;

# the value lfs reports when inode count quota is unlimited
my $LFS_QUOTA_INODE_UNLIMITED = 0;

# what value to set for minimal size quota
my $LFS_QUOTA_SIZE_MIN = 1;

# what value to set for minimal inode quota
my $LFS_QUOTA_INODE_MIN = 1;

# what value to use if no quota limit is set 
my $NO_QUOTA	       = "unlimited";

# what value to report if grace periods are not active
my $TIMER_INACTIVE     = "inactive";

# regular expression matching illegal filename/path characters
my $ILLEGAL_PATH_REGEX = qr/[\|\\\012\r\n\t\013\*\"\?\<\:\>]/; 

# binary SI units labels from bytes to yobibytes
my $BINARY_UNIT_LABELS  = ["B","KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"];

# decimal SI unit labels from bytes to yottabytes
my $DECIMAL_UNIT_LABELS = ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];

# time unit labels from seconds to years
my $TIME_UNIT_LABELS = ["s", "m",  "h",   "d",    "w",      "y"];
my $TIME_UNIT_RATIOS = [  1,  60, 3600, 86400, 604800, 31536000];

# for unitless inode counts
my $DECIMAL_PREFIXES = ["", "k", "M", "G", "T", "P", "E", "Z", "Y"];

# ratio of the next unit value at which to switch to it 
# (e.g. 0.8 implies we would say "0.8 kB" instead of "800 B" 
# whereas 1.2 would mean we would say "1199 B" but "1.2 kB" instead of "1200 B")
my $HUMAN_TRIGGER_RATIO = 0.8;

# the order of output columns in table output
my $COLUMN_ORDER = ["filesystem","type","name","size-used","size-softlimit","size-hardlimit","size-remaining","size-grace","inode-used","inode-softlimit","inode-hardlimit","inode-remaining","inode-grace","timestamp"];

# separator between value and units in output
my $OUTPUT_UNIT_SEP = "";


#################################################################################
# If run as a script (rather than used or required from elsewhere), pass 
# command-line arguments to run. 
#################################################################################
lustre_operator::run(@ARGV) unless caller();


=head1 NAME

lustre_operator - a wrapper script for Lustre's 
lfs command suitable for sudo use.

=head1 GENERAL

=head2 SYNOPSIS

lustre_operator B<<lfs_binary>> B<<lustre_filesystem>> B<<command>> [B<<options>>]

Supports the C<getquota>, C<setquota>, and C<find> lfs commands.

=head2 ARGUMENTS

=over

=item B<lfs_binary>

An absolute path to the lfs binary.  

For security reasons when using this script with sudo, the path to the lfs binary should 
ALWAYS be included in the sudoers rule and the lfs binary itself should not be writable 
by any unauthorised users on any host on which users are given sudo access 
(see CONFIGURATION AND ENVIRONMENT) for more information. If you allowed sudo execution 
of lustre_operator without specifying the lfs_binary in the sudoers rule, this would 
open a gaping whole for a root exploit. 

=item B<lustre_filesystem>

An absolute path to the lustre filesystem mount point, as specified 
in F</proc/mounts> and/or F</etc/mtab> (and reported by I<mount>). 

This can also be specified in the sudoers rule to limit user(s) to operating specific filesystems. 

=item B<command>

Command (C<getquota>, C<setquota>, or C<find>) to run.

This could also be specified in the sudoers file in order to limit user(s) to running only some 
commands on specific filesystems. 

=back

=head2 OPTIONS

=over

=item [--help|-?]

Print full documentation to STDOUT and exit

=back

=head1 GETQUOTA

=head2 SYNOPSIS

lustre_operator B<<lfs_binary>> B<<lustre_filesystem>> getquota [B<<options>>]

=head2 OPTIONS

=over

=item [--help|-?]

Print getquota documentation to STDOUT and exit

=item [--user|-u <<uname>>|<<uid>>]

username or uid for a user whose quota you wish to report 
(you can specify this option multiple times)

=item [--group|-g <<gname>>|<<gid>>]

group name or gid for a group whose quota you wish to report 
(you can specify this option multiple times)

=item [--human|-h]

use human readable units
(synonym for C<--size-units human_binary --inode-units human --time-units human>)

=item [--human_decimal|-d]

use decimal (kB=1000^1, MB=1000^2, GB=1000^3, ...) rather 
than binary (KiB=1024^1, MiB=1024^2, GiB=1024^3, ...) size units 
for human readable output (synonym for 
C<--size-units human_decimal --inode-units human --time-units human>)

overrides --human

=item [--size-units|-s] <<size_units>>

use specified units for size. <<size_units>> can be: ""|"B"|"kB"|"KiB"|"MB"|"MiB"|"GB"|"GiB"|"TB"|"TiB"|"PB"|"PiB"|"EB"|"EiB"|"ZB"|"ZiB"|"YB"|"YiB"|"human_binary"|"human_decimal"

the default is <<size_units>>="B"

=item [--inode-units|-i] <<inode_units>>

use specified units for inode count. <<inode_units>> can be: ""|"k"|"M"|"G"|"T"|"P"|"E"|"Z"|"Y"|"human"

the default is <<inode_units>>=""

=item [--time-units|-t] <<time_units>>

use specified units for grace time. <<time_units>> can be: ""|"s"|"m"|"h"|"d"|"w"|"y"|"human"

the default is <<time_units>>="s"

=item [--format|-f] <<format>>

specify output format. <<format>> can be: "json"|"csv"|"tsv"|"spacesv"|"dumper"

=item [--column|-c] <<column_header>>

select a column to include in output instead of the default of all columns 
if none of these options are given

can be specified multiple times in which case all specified columns are included 
and order is preserved (as listed on the command line). 

=back

=head2 EXAMPLES

=over

=item get quota information for the current user and group on /mnt/lustre1:

C<lustre_operator /usr/bin/lfs /mnt/lustre1 getquota>

=item get quota information for user1 on /mnt/lustre1:

C<lustre_operator /usr/bin/lfs /mnt/lustre1 getquota --user user1>

=item get quota information for group1 on /mnt/lustre1:

C<lustre_operator /usr/bin/lfs /mnt/lustre1 getquota --group group1>

=back

=head1 SETQUOTA

=head2 SYNOPSIS

lustre_operator B<<lfs_binary>> B<<lustre_filesystem>> setquota 
-u|--user|-g|--group <<uname>>|<<uid>>|<<gname>>|<<gid>> [options]

=head2 OPTIONS

=over

=item [--help|-?]

Print setquota documentation to STDOUT and exit

=item [--size-softlimit|-b <<size-softlimit>>] 

Set the size softlimit, specified in bytes or in specified units (e.g. "1.5TB" or "2 GiB")

Unit labels supported: "B", "kB", "KiB", "MB", "MiB", "GB", "GiB", "TB", "TiB", "PB", "PiB", "EB", "EiB", "ZB", "ZiB", "YB", "YiB"

=item [--force-size-softlimit]

Force setting of size softlimit, even if it will put user(s) and/or group(s) over quota

=item [--size-hardlimit|-B <<size-hardlimit>>]

Set the size hardlimit, specified in bytes or in specified units (e.g. "1.5TB" or "2 GiB")

Unit labels supported: "B", "kB", "KiB", "MB", "MiB", "GB", "GiB", "TB", "TiB", "PB", "PiB", "EB", "EiB", "ZB", "ZiB", "YB", "YiB"

=item [--force-size-hardlimit]

Force setting of size hardlimit, even if it will put user(s) and/or group(s) over quota

=item [--inode-softlimit|-i <<inode-softlimit>>]

Set the inode softlimit, specified in number of files or with specified SI prefix (e.g. "1.5M" for 1500000)

Unit labels supported: "k", "M", "G", "T", "P", "E", "Z", "Y"

=item [--force-inode-softlimit]

Force setting of inode softlimit, even if it will put user(s) and/or group(s) over quota

=item [--inode-hardlimit|-I <<inode-hardlimit>>]

Set the inode hardlimit, specified in number of files or with specified SI prefix (e.g. "1.5M" for 1500000)

Unit labels supported: "k", "M", "G", "T", "P", "E", "Z", "Y"

=item [--force-inode-hardlimit]

Force setting of inode hardlimit, even if it will put user(s) and/or group(s) over quota

=back

=head2 EXAMPLES

=over

=item set the quota for user user2 on /mnt/lustre2 to 1 TebiByte 
(1024^4 bytes) and 1 million inodes (files):

C<lustre_operator /usr/bin/lfs /mnt/lustre1 setquota --user user2 
--size-hardlimit 1TiB  --inode-hardlimit 1M>

=item set the quota for group group2 on /mnt/lustre2 to 100 megabytes 
(100 * 1000^2 bytes) and 1500 inodes:

C<lustre_operator /usr/bin/lfs /mnt/lustre2 setquota --group group2 
--size-hardlimit 100MB --inode-hardlimit 1.5k>

=item set the quota for group group2 on /mnt/lustre2 to 1 block and 
1 inode (this is the minimum quota):

C<lustre_operator /usr/bin/lfs /mnt/lustre2 setquota --group group2 
--size-hardlimit 1 --inode-hardlimit 1>

=back

=head1 FIND

=head2 SYNOPSIS

lustre_operator B<<lfs_binary>> B<<lustre_filesystem>> find B<<dir_or_file_list>> [options]

=head2 ARGUMENTS

=over

=item B<<dir_or_file_list>>

List of directories and/or files from which to begin the recursive find.

=back

=head2 OPTIONS

=over

=item [--help|-?]

Print find documentation to STDOUT and exit

=item [--print0|-P]

Print matching files separated by NUL character instead of newline (which is the default)

=item [--atime|--not-atime [+-]N]

Match files last accessed N days ago (C<not-> inverts match)

C<+> prefix matches files last accessed N or more days ago. 

C<-> prefix matches files last accessed N or fewer days ago. 

=item [--mtime|--not-mtime [+-]N]

Match files last modified N days ago (C<not-> inverts match) 

C<+> prefix matches files last modified N or more days ago. 

C<-> prefix matches files last modified N or fewer days ago. 

=item [--ctime|--not-ctime [+-]N]

Match files whose status was last changed N days ago (C<not-> inverts match) 

C<+> prefix matches files whose status was last changed N or more days ago. 

C<-> prefix matches files whose status was last changed N or fewer days ago. 

=item [--name|--not-name <pattern>]

Match file whose name (not path) matches pattern (C<not-> inverts match) 

=item [--obd|--not-obd <uuid[s]>]

Match files who have an object on the specified OST or OSTs (C<not-> inverts match) 

<uuid[s]> can be a comma-delimited list of OST uuids.

=item [--size|--not-size [+-]N[B|KiB|MiB|GiB|TiB|PiB|EiB|ZiB|YiB|kB|MB|GB|TB|PB|EB|ZB|YB]]

Match files with size specified in bytes (default) or in specified units (C<not-> inverts match) 

C<+> prefix matches files whose size is the specified size or larger.

C<-> prefix matches files whose size is the specified size or smaller.

=item [--type|--not-type <filetype>]

Match files of the specified type (C<not-> inverts match), where <filetype> is one of: 
C<b> - block, 
C<c> - character, 
C<d> - directory, 
C<p> - pipe, 
C<f> - file, 
C<l> - symlink, 
C<s> - socket, 
C<D> - Door (Solaris).

=item [--gid|--not-gid <gid>]

Match files owned by specified group (by numeric gid) (C<not-> inverts match) 

=item [--group|--not-group <gname>]

Match files owned by specified group (by name) (C<not-> inverts match) 

=item [--uid|--not-uid <uid>]

Match files owned by specified user (by numeric uid) (C<not-> inverts match) 

=item [--user|--not-user <uname>]

Match files owned by specified user (by name) (C<not-> inverts match) 

=back

=head2 EXAMPLES

=over 

=item find all files named F<*file*> under /mnt/lustre/dir3:

C<lustre_operator /usr/bin/lfs /mnt/lustre3 find /mnt/lustre3/dir3 --name \*file\*>

=back

=cut



#################################################################################
# run - entry point when run as a script
# 
# parses arguments/options and dispatches to subcommand run_* handler
#
# Inputs
#    list of command-line arguments following the find command
# Returns
#    Nothing (never returns)
#################################################################################
sub run {
    my @args = @_;
    
    #############################################################################
    # Process command-line
    #############################################################################
    if (defined($args[0]) && $args[0] =~ m/(--help|-[?])/) {
	# shortcut to full help (and exit)
	exit_full_help();
    }
    my $lfs_bin_taint = shift @args or error_exit_usage("Must specify absolute path to lfs binary as first argument", "GENERAL");
    # absolute path not strictly required for security, but we are forcing it to 
    # be required to suggest good practice (especially when running via sudo)
    my $lfs_bin = untaint_valid_abs_path($lfs_bin_taint) or error_exit_usage("Specified lfs binary [$lfs_bin_taint] is not a valid absolute path", "GENERAL");
    # not only should lfs_bin be an absolute path but it should be executable and 
    # it should be either a plain file or a symbolic link. 
    # The real security here comes from requiring the lfs binary to be included 
    # at the beginning of the command line such that it can be included in a 
    # sudoers rule (it should ALWAYS be included in sudoers)
    (-x $lfs_bin && (-f $lfs_bin || -l $lfs_bin)) or error_exit_usage("Specified lfs binary [$lfs_bin] is not executable", "GENERAL");
    
    my $lustre_filesystem_taint = shift @args or error_exit_usage("Must specify lustre_filesystem as second argument", "GENERAL");
    # verify that lustre_filesystem is listed in /proc/mounts or /etc/mtab (and untaint)
    my $lustre_filesystem = untaint_valid_mount_point($lustre_filesystem_taint) or error_exit("Invalid lustre filesystem [$lustre_filesystem_taint], must specify absolute path to lustre mount point (as listed in /proc/mounts or /etc/mtab)");
    
    my $lfs_cmd = shift @args or error_exit_usage("Must specify getquota, setquota, or find as third argument", "GENERAL");
    $lfs_cmd =~ m/^(getquota|setquota|find|[-]\S+)$/ or error_exit_usage("Unrecognized command: $lfs_cmd");

    #############################################################################
    # Launch subcommand handlers
    #############################################################################
    if ($lfs_cmd eq "getquota") {
	run_getquota($lfs_bin, $lustre_filesystem,  @args);
    } elsif ($lfs_cmd eq "setquota") {
	run_setquota($lfs_bin, $lustre_filesystem, @args);
    } elsif ($lfs_cmd eq "find") {
	run_find($lfs_bin, $lustre_filesystem, @args);
    } else {
	# did not specify command, check for generic options
	unshift @args, $lfs_cmd;
	my $help = 0;
	GetOptionsFromArray( \@args,
			     'help|?' => \$help ) or error_exit_usage("could not process generic options", "GENERAL");
	if ($help) {
	    exit_full_help();
	}
    }
}


#################################################################################
# run_getquota - handle the getquota subcommand
# 
# parses arguments/options and handles the getquota subcommand 
#
# Inputs
#    1: lfs binary
#    2: lustre mount point
#    remaining: list of command-line arguments following the find command
# Returns
#    Nothing (never returns)
#################################################################################
sub run_getquota {
    my $lfs_bin = shift;
    my $filesystem = shift;
    my @args = @_;

    # getquota: Display disk usage and limits.
    my @users;
    my @groups;
    
    # columns to include in output 
    my @columns;
    
    # units
    my $size_units="";
    my $inode_units="";
    my $time_units="";
    
    # output format: json, csv, tsv, or spacesv (default: tsv)
    my $format = "tsv"; 

    # get options
    GetOptionsFromArray( \@args,
			 "user|u=s" => \@users,
			 "group|g=s" => \@groups,
			 "column|c=s" => \@columns,
			 "format|f=s" => \$format,
			 "size-units|s=s" => \$size_units,
			 "inode-units|i=s" => \$inode_units,
			 "time-units|t=s" => \$time_units,
			 "human|h" => sub {
			     if (!$size_units) {
				 $size_units = "human_binary";
			     }
			     if (!$inode_units) {
				 $inode_units = "human";
			     }
			     if (!$time_units) {
				 $time_units = "human";
			     }
			 },
			 "human_decimal|d" => sub {
			     if (!$size_units) {
				 $size_units = "human_decimal";
			     }
			     if (!$inode_units) {
				 $inode_units = "human";
			     }
			     if (!$time_units) {
				 $time_units = "human";
			     }
			 },
			 "help|?" => sub { exit_usage("Help for getquota command:","GETQUOTA") },
	) or error_exit_usage("Could not parse getquota options", "GETQUOTA");
    
    if (@users <= 0 && @groups <= 0) {
	error_exit_usage("Nothing to do for getquota: please specify user(s) and/or group(s)", "GETQUOTA");
    }
    
    ($format =~ m/^(json|csv|tsv|spacesv|dumper)$/) or error_exit_usage("Unsupported format $format", "GETQUOTA");

    # get quotas into hash
    my %quotas;
    foreach my $user (@users) {
	$quotas{user}{$user} = lfs_get_quota($lfs_bin, $filesystem, "user", $user);
    }
    foreach my $group (@groups) {
	$quotas{group}{$group} = lfs_get_quota($lfs_bin, $filesystem, "group", $group);
    }
    
    # print quotas
    output_quotas(\%quotas, $format, $size_units, $inode_units, $time_units, \@columns);
}


#################################################################################
# run_setquota - setquota subcommand handler
# 
# parses arguments/options and handles the setquota subcommand 
#
# Inputs
#    1: lfs binary
#    2: lustre mount point
#    remaining: list of command-line arguments following the find command
# Returns
#    Nothing (never returns)
#################################################################################
sub run_setquota {
    my $lfs_bin = shift;
    my $filesystem = shift;
    my @args = @_;

    # options
    my @users;
    my @groups;
    my $size_softlimit = undef;
    my $force_size_softlimit = 0;
    my $size_hardlimit = undef;
    my $force_size_hardlimit = 0;
    my $inode_softlimit = undef;
    my $force_inode_softlimit = 0;
    my $inode_hardlimit = undef;
    my $force_inode_hardlimit = 0;
    
    # get options
    GetOptionsFromArray( \@args,
			 "user|u=s"              => \@users,
			 "group|g=s"             => \@groups,
			 "size-softlimit|b=s"    => \$size_softlimit,
			 "force-size-softlimit"  => \$force_size_softlimit,
			 "size-hardlimit|B=s"    => \$size_hardlimit,
			 "force-size-hardlimit"  => \$force_size_hardlimit,
			 "inode-softlimit|i=s"   => \$inode_softlimit,	
			 "force-inode-softlimit" => \$force_inode_softlimit,	
			 "inode-hardlimit|I=s"   => \$inode_hardlimit,
			 "force-inode-hardlimit" => \$force_inode_hardlimit,
			 "help|?"                => sub { exit_usage("Help for setquota command:","SETQUOTA") },
	) or error_exit_usage("Could not parse setquota options", "SETQUOTA");
    
    if (@users <= 0 && @groups <= 0) {
	error_exit_usage("Nothing to do for setquota: please specify user(s) and/or group(s)", "SETQUOTA");
    }

    my %newquota;
    my %checkquota;
    if (defined($size_softlimit)) {
	if ($size_softlimit eq $NO_QUOTA) {
	    $newquota{"size-softlimit"} = $NO_QUOTA; 
	} else {
	    $newquota{"size-softlimit"} = convert_to_bytes($size_softlimit);
	}
	if ( !$force_size_softlimit ) {
	    $checkquota{"size-softlimit"} = $newquota{"size-softlimit"};
	}
    }
    if (defined($size_hardlimit)) {
	if ($size_hardlimit eq $NO_QUOTA) {
	    $newquota{"size-hardlimit"} = $NO_QUOTA;
	} else {
	    $newquota{"size-hardlimit"} = convert_to_bytes($size_hardlimit);
	}
	if ( !$force_size_hardlimit ) {
	    $checkquota{"size-hardlimit"} = $newquota{"size-hardlimit"};
	}
    }
    if (defined($inode_softlimit)) {
	if ($inode_softlimit eq $NO_QUOTA) {
	    $newquota{"inode-softlimit"} = $NO_QUOTA;
	} else {
	    $newquota{"inode-softlimit"} = convert_to_inodes($inode_softlimit);
	}
	if ( !$force_inode_softlimit ) {
	    $checkquota{"inode-softlimit"} = $newquota{"inode-softlimit"};
	}
    }
    if (defined($inode_hardlimit)) {
	if ($inode_hardlimit eq $NO_QUOTA) {
	    $newquota{"inode-hardlimit"} = $NO_QUOTA;
	} else {
	    $newquota{"inode-hardlimit"} = convert_to_inodes($inode_hardlimit);
	}
	if ( !$force_inode_hardlimit ) {
	    $checkquota{"inode-hardlimit"} = $newquota{"inode-hardlimit"};
	}
    }
    
    if ( keys %newquota < 1) {
	error_exit("no limits specified, nothing to do.");
    }

    if ( keys %checkquota > 0 ) {
	# check the existing quota for each user and group against the new proposed quota
	# refuse to set quota over the existing usage without a --force-* option
	my @existing_quotas;
	foreach my $user (@users) {
	    push @existing_quotas, lfs_get_quota($lfs_bin, $filesystem, "user", $user);
	}
	foreach my $group (@groups) {
	    push @existing_quotas, lfs_get_quota($lfs_bin, $filesystem, "group", $group);
	}
	
	# check proposed quotas against existing usage (error_exit if change would put any user/group over)
	check_quota_change(\@existing_quotas, \%checkquota);
    }
    
    # set quota for each user and group
    foreach my $user (@users) {
	lfs_set_quota($lfs_bin, $filesystem, "user", $user, \%newquota);
    }
    foreach my $group (@groups) {
	lfs_set_quota($lfs_bin, $filesystem, "group", $group, \%newquota);
    }
}


#################################################################################
# run_find - find subcommand handler
# 
# parses arguments/options and handles the find subcommand 
#
# Inputs
#    1: lfs binary
#    2: lustre mount point
#    remaining: list of command-line arguments following the find command
# Returns
#    Nothing (never returns) 
#################################################################################
sub run_find {
    my $lfs_bin = shift;
    my $filesystem = shift;
    my @args = @_;

    # stat the mount point to get the dev_t for the filesystem (to check each <dir|file> entry against)
    (my $fs_dev, undef) = stat $filesystem or error_exit_usage("could not stat mount point $filesystem", "FIND");

    # process dir_or_file_list arguments up until the first option (beginning with "--") 
    my @dir_or_file_list;
  DIRFILEARG: while (my $dir_or_file = shift @args) {
      if (defined($dir_or_file) && $dir_or_file !~ m/^--/) {
	  # have a non-option argument, must be a valid path to plain file or dir (possibly following symlinks)
	  # and must be located on the same device as $filesystem ($fs_dev) 
	  # this is sufficient for security as `lfs find` will not follow symlinks during the find traversal
	  $dir_or_file = untaint_valid_path($dir_or_file) or error_exit_usage("$dir_or_file is not a valid path", "FIND");

	  # verify that $dir_or_file is either a plain file or dir (-f and -d will follow symlinks, as does `lfs find`)
	  ( -f $dir_or_file || -d $dir_or_file ) or error_exit("$dir_or_file is not a plain file or directory");
	  
	  # stat also follows symlinks, so in case of symlinks it is the target stat that we will get
	  (my $dir_or_file_dev, undef) = stat $dir_or_file or error_exit("could not stat <dir|file> $dir_or_file");
	  
	  # verify dir_or_file's dev is the same as the filesystem's dev
	  ($dir_or_file_dev == $fs_dev) or error_exit("$dir_or_file and $filesystem are not on the same device ($dir_or_file is on device $dir_or_file_dev but $filesystem is on device $fs_dev)");
	  push @dir_or_file_list, $dir_or_file;
      } else {
	  # have either an option argument (starting with '--') or no argument, put it back
	  unshift @args, $dir_or_file;
	  # end dir_or_file_list argument processing and begin option processing
	  last DIRFILEARG;
      }
  }
    
    # get options
    my $print0 = 0;
    my $maxdepth;
    my $atime;
    my $not_atime;
    my $mtime;
    my $not_mtime;
    my $ctime;
    my $not_ctime;
    my $name;
    my $not_name;
    my $obd;
    my $not_obd;
    my $size;
    my $not_size;
    my $type;
    my $not_type;
    my $gid;
    my $not_gid;
    my $group;
    my $not_group;
    my $uid;
    my $not_uid;
    my $user;
    my $not_user;
    GetOptionsFromArray( \@args,
			 "print0|P"          => \$print0,
			 "maxdepth|D=i{1,1}" => \$maxdepth,  # N
			 "atime=s{1,1}"      => \$atime,     # [+-]N
			 "not-atime=s{1,1}"  => \$not_atime, # [+-]N
			 "mtime=s{1,1}"      => \$mtime,     # [+-]N
			 "not-mtime=s{1,1}"  => \$not_mtime, # [+-]N
			 "ctime=s{1,1}"      => \$ctime,     # [+-]N
			 "not-ctime=s{1,1}"  => \$not_ctime, # [+-]N
			 "name=s{1,1}"       => \$name,      # <pattern>
			 "not-name=s{1,1}"   => \$not_name,  # <pattern>
			 "obd=s{1,1}"        => \$obd,       # <uuids>
			 "not-obd=s{1,1}"    => \$not_obd,   # <uuids>
			 "size=s{1,1}"       => \$size,      # [+-]N[B|KiB|MiB|GiB|TiB|PiB|EiB|ZiB|YiB|kB|MB|GB|TB|PB|EB|ZB|YB]
			 "not-size=s{1,1}"   => \$not_size,  # [+-]N[B|KiB|MiB|GiB|TiB|PiB|EiB|ZiB|YiB|kB|MB|GB|TB|PB|EB|ZB|YB]
			 "type=s{1,1}"       => \$type,      # <filetype>
			 "not-type=s{1,1}"   => \$not_type,  # <filetype>
			 "gid=i{1,1}"        => \$gid,       # <gid>
			 "not-gid=i{1,1}"    => \$not_gid,   # <gid>
			 "group=s{1,1}"      => \$group,     # <group>
			 "not-group=s{1,1}"  => \$not_group, # <group>
			 "uid=i{1,1}"        => \$uid,       # <uid>
			 "not-uid=i{1,1}"    => \$not_uid,   # <uid>
			 "user=s{1,1}"       => \$user,      # <username>
			 "not-user=s{1,1}"   => \$not_user,  # <username>
			 "help|?" => sub { exit_usage("Help for find command:","FIND") },
	) or error_exit_usage("Could not parse find options", "FIND");

    # check that we have some dir_or_file entries
    (@dir_or_file_list > 0) or error_exit_usage("must specify <dir_or_file_list> before options", "FIND");
    
    my @lfs_args;
    push @lfs_args, "find";
    
    if (defined($atime) && defined($not_atime)) {
	error_exit("cannot specify both --atime and --not-atime");
    }
    
    if (defined($atime)) {
	$atime =~ m/^([-+]{0,1}[0-9]+)$/ or error_exit_usage("atime was not [+-]N ($atime)", "FIND");
	$atime = $1;
	push @lfs_args, '--atime', $atime;
    }

    if (defined($not_atime)) {
	$not_atime =~ m/^([-+]{0,1}[0-9]+)$/ or error_exit_usage("not_atime was not [+-]N ($not_atime)", "FIND");
	$not_atime = $1;
	push @lfs_args, '!', '--atime', $not_atime;
    }

    if (defined($mtime) && defined($not_mtime)) {
	error_exit("cannot specify both --mtime and --not-mtime");
    }
    
    if (defined($mtime)) {
	$mtime =~ m/^([-+]{0,1}[0-9]+)$/ or error_exit_usage("mtime was not [+-]N ($mtime)", "FIND");
	$mtime = $1;
	push @lfs_args, '--mtime', $mtime;
    }

    if (defined($not_mtime)) {
	$not_mtime =~ m/^([-+]{0,1}[0-9]+)$/ or error_exit_usage("not_mtime was not [+-]N ($not_mtime)", "FIND");
	$not_mtime = $1;
	push @lfs_args, '!', '--mtime', $not_mtime;
    }

    if (defined($ctime) && defined($not_ctime)) {
	error_exit("cannot specify both --ctime and --not-ctime");
    }
    
    if (defined($ctime)) {
	$ctime =~ m/^([-+]{0,1}[0-9]+)$/ or error_exit_usage("ctime was not [+-]N ($ctime)", "FIND");
	$ctime = $1;
	push @lfs_args, '--ctime', $ctime;
    }

    if (defined($not_ctime)) {
	$not_ctime =~ m/^([-+]{0,1}[0-9]+)$/ or error_exit_usage("not_ctime was not [+-]N ($not_ctime)", "FIND");
	$not_ctime = $1;
	push @lfs_args, '!', '--ctime', $not_ctime;
    }

    if (defined($maxdepth)) {
	$maxdepth =~ m/^([0-9]+)$/ or error_exit_usage("maxdepth was not an integer ($maxdepth)", "FIND");
	$maxdepth = $1;
	push @lfs_args, '--maxdepth', $maxdepth;
    }
    
    if (defined($name) && defined($not_name)) {
	error_exit("cannot specify both --name and --not-name");
    }
    
    if (defined($name)) {
	# <pattern>
	$name =~ m/^([^\/]+)$/ or error_exit_usage("name contained a '/' ($name)", "FIND");
	$name = $1;
	push @lfs_args, '--name', $name;
    }

    if (defined($not_name)) {
	# <pattern>
	$not_name =~ m/^([^\/]+)$/ or error_exit_usage("not_name contained a '/' ($not_name)", "FIND");
	$not_name = $1;
	push @lfs_args, '!', '--name', $not_name;
    }

    if ($print0) {
	push @lfs_args, '--print0';
    }
    
    if (defined($obd) && defined($not_obd)) {
	error_exit("cannot specify both --obd and --not-obd");
    }
    
    if (defined($obd)) {
	$obd =~ m/^([-_,[:alnum:]]+)$/ or error_exit_usage("obd was not <uuid[s]> ($obd)", "FIND");
	$obd = $1;
	push @lfs_args, '--obd', $obd;
    }
    
    if (defined($not_obd)) {
	$obd =~ m/^([-_,[:alnum:]]+)$/ or error_exit_usage("not_obd was not <uuid[s]> ($not_obd)", "FIND");
	$not_obd = $1;
	push @lfs_args, '!', '--obd', $not_obd;
    }

    if (defined($size) && defined($not_size)) {
	error_exit("cannot specify both --size and --not-size");
    }
    
    if (defined($size)) {
	# [+-]N[B|KiB|MiB|GiB|TiB|PiB|EiB|ZiB|YiB|kB|MB|GB|TB|PB|EB|ZB|YB]
	$size =~ m/^([-+]{0,1})([0-9]+(B|KiB|MiB|GiB|TiB|PiB|EiB|ZiB|YiB|kB|MB|GB|TB|PB|EB|ZB|YB){0,1})$/ or error_exit_usage("size was not [+-]N[B|KiB|MiB|GiB|TiB|PiB|EiB|ZiB|YiB|kB|MB|GB|TB|PB|EB|ZB|YB] ($size)", "FIND");
	my $plus_minus = $1;
	my $formatted_units = $2;
	my $bytes = convert_to_bytes($formatted_units) or error_exit("could not convert size units to bytes ($size)");
	push @lfs_args, '--size', $plus_minus.$bytes;
    }

    if (defined($not_size)) {
	# [+-]N[B|KiB|MiB|GiB|TiB|PiB|EiB|ZiB|YiB|kB|MB|GB|TB|PB|EB|ZB|YB]
	$not_size =~ m/^([-+]{0,1})([0-9]+(B|KiB|MiB|GiB|TiB|PiB|EiB|ZiB|YiB|kB|MB|GB|TB|PB|EB|ZB|YB){0,1})$/ or error_exit_usage("not_size was not [+-]N[B|KiB|MiB|GiB|TiB|PiB|EiB|ZiB|YiB|kB|MB|GB|TB|PB|EB|ZB|YB] ($size)", "FIND");
	my $plus_minus = $1;
	my $formatted_units = $2;
	my $bytes = convert_to_bytes($formatted_units) or error_exit("could not convert not_size units to bytes ($not_size)");
	push @lfs_args, '!', '--size', $plus_minus.$bytes;
    }

    if (defined($type) && defined($not_type)) {
	error_exit("cannot specify both --type and --not-type");
    }

    if (defined($type)) {
	# <filetype> == [bcdpflsD] 
	$type =~ m/^([bcdpflsD])$/ or error_exit_usage("type was not [b|c|d|p|f|l|s|D] ($type)", "FIND");
	$type = $1;
	push @lfs_args, '--type', $type;
    }

    if (defined($not_type)) {
	# <filetype> == [bcdpflsD] 
	$type =~ m/^([bcdpflsD])$/ or error_exit_usage("not_type was not [b|c|d|p|f|l|s|D] ($type)", "FIND");
	$type = $1;
	push @lfs_args, '!', '--type', $type;
    }

    if (defined($gid) && defined($not_gid)) {
	error_exit("cannot specify both --gid and --not-gid");
    }

    if (defined($gid)) {
	# <gid>
	$gid =~ m/^([0-9]+)$/ or error_exit_usage("gid was not an integer ($gid)", "FIND");
	$gid = $1;
	push @lfs_args, '--gid', $gid;
    }

    if (defined($not_gid)) {
	# <gid>
	$gid =~ m/^([0-9]+)$/ or error_exit_usage("not_gid was not an integer ($gid)", "FIND");
	$gid = $1;
	push @lfs_args, '!', '--gid', $gid;
    }

    if (defined($group) && defined($not_group)) {
	error_exit("cannot specify both --group and --not-group");
    }

    if (defined($group)) {
	# <group_name>
	$group =~ m/^([a-z_][a-z0-9_-]{0,31})$/ or error_exit_usage("group was not valid ($group)", "FIND");
	$group = $1;
	push @lfs_args, '--group', $group;
    }

    if (defined($not_group)) {
	# <group_name>
	$not_group =~ m/^([a-z_][a-z0-9_-]{0,31})$/ or error_exit_usage("not_group was not valid ($not_group)", "FIND");
	$not_group = $1;
	push @lfs_args, '!', '--group', $not_group;
    }

    if (defined($uid) && defined($not_uid)) {
	error_exit("cannot specify both --uid and --not-uid");
    }

    if (defined($uid)) {
	# <uid>
	$uid =~ m/^([0-9]+)$/ or error_exit_usage("uid was not an integer ($uid)", "FIND");
	$uid = $1;
	push @lfs_args, '--uid', $uid;
    }

    if (defined($not_uid)) {
	# <uid>
	$not_uid =~ m/^([0-9]+)$/ or error_exit_usage("not_uid was not an integer ($not_uid)", "FIND");
	$not_uid = $1;
	push @lfs_args, '!', '--uid', $not_uid;
    }

    if (defined($user) && defined($not_user)) {
	error_exit("cannot specify both --user and --not-user");
    }

    if (defined($user)) {
	# <user_name>
	$user =~ m/^([a-z_][a-z0-9_-]{0,31})$/ or error_exit_usage("user was not valid ($user)", "FIND");
	$user = $1;
	push @lfs_args, '--user', $user;
    }

    if (defined($not_user)) {
	# <user_name>
	$not_user =~ m/^([a-z_][a-z0-9_-]{0,31})$/ or error_exit_usage("not_user was not valid ($not_user)", "FIND");
	$not_user = $1;
	push @lfs_args, '!', '--user', $not_user;
    }
    
    # dir_or_file_list at the end
    push @lfs_args, @dir_or_file_list;

    # exec to run lfs find (never to return)
    exec_lfs($lfs_bin, @lfs_args);

    error_exit("unexpected error in exec_lfs find");
}

#################################################################################
# untaint_valid_mount_point - return untainted mount point if it is valid
# 
# verifies the given mount point is specified as an absolute path, then 
# checks if mount point is valid by looking it up in /proc/mounts or /etc/mtab
#
# Inputs
#    1: mount point
# Returns
#    untainted mount point or undef if not valid
#################################################################################
sub untaint_valid_mount_point {
    my $mount_point = shift;
    my $validated_filesystem = undef;

    # We need to untaint the mount_point input. There is no problem per se with it 
    # being non-absolute or non-canonical - the real test is whether it is listed 
    # in /proc/mounts or /etc/mtab.  However, we do require it to be an absolute path 
    # because (a) that is usual for mount point specification anyway and (b) the 
    # valid_path check (included within valid_abs_path) also makes sure that there are 
    # no illegal characters (such as shell metacharacters). We never call a shell to 
    # interpret the commands, so this is extra paranoid (but it would protect against 
    # exotic situations such as if the lfs binary was replaced by a shell wrapper). 
    if ( valid_abs_path($mount_point) ) {
	# have valid path based on regex, check for it in /proc/mounts or /etc/mtab
	my $mfile = "/proc/mounts";
	if (! open MOUNTS, "<$mfile" ) {
	    $mfile = "/etc/mtab";
	    open MOUNTS, "<$mfile" or error_exit("could not open /proc/mounts or /etc/mtab for reading");
	}
	MOUNTLINE: while( my $mountline = <MOUNTS> ) {
	    chomp $mountline;
	    my ($spec, $mountpoint, $type, undef) = split /\s+/, $mountline, 4;
	    if ($mountpoint eq $mount_point) {
		if ($type eq "lustre") {
		    # validated, untaint
		    $mountpoint =~ m/^(\/.*)$/ or error_exit("did not have absolute path as mount point: $mountpoint");
		    $validated_filesystem = $1;
		    last MOUNTLINE;
		} else {
		    error_exit("$mount_point was listed in $mfile but was not of type lustre");
		}
	    }
	}
	close MOUNTS;
    }
    return $validated_filesystem;
}

#################################################################################
# untaint_valid_abs_path - return untainted absolute path if it appears valid
# 
# Inputs
#    1: absolute path
# Returns
#    untainted absolute path or undef if not valid
#################################################################################
sub untaint_valid_abs_path {
    my $filepath = shift;
    if (valid_abs_path($filepath)) {
	$filepath =~ m/^(\/.*)$/;
	$filepath = $1;
	return $filepath;
    } else {
	return undef;
    }
}

#################################################################################
# valid_abs_path - check if a path is absolute and plausibly valid
# 
# Inputs
#    1: absolute path
# Returns
#    1 if valid, undef if not
#################################################################################
sub valid_abs_path {
    my $filepath = shift;
    ($filepath =~ /^\//) and valid_path($filepath) ? 1 : undef;
}

#################################################################################
# untaint_valid_path - return untainted path if it appears valid
# 
# Inputs
#    1: path
# Returns
#    untainted path or undef if not valid
#################################################################################
sub untaint_valid_path {
    my $filepath = shift;
    if (valid_path($filepath)) {
	$filepath =~ m/^(.*)$/;
	$filepath = $1;
	return $filepath;
    } else {
	return undef;
    }
}

#################################################################################
# valid_path - check if a path is plausibly valid (contains no illegal characters)
# 
# Inputs
#    1: path
# Returns
#    1 if valid, undef if not
#################################################################################
sub valid_path {
    my $filepath = shift;
    $filepath !~ /$ILLEGAL_PATH_REGEX/ ? 1 : undef;
}

#################################################################################
# over_quota - check if usage is over quota (handling unlimited quotas)
# 
# Inputs
#    1: quota value
#    2: used value
# Returns
#    1 if over quota, undef if not
#################################################################################
sub over_quota {
    my $quota = shift || $NO_QUOTA;
    my $used = shift or error_exit("over_quota called without used value");

    $quota =~ m/^($NO_QUOTA|[0-9]+)$/ or error_exit("quota [$quota] was neither $NO_QUOTA nor an integer");

    if (($quota eq $NO_QUOTA) ||
	($quota >= $used)) {
	# not over quota
	return undef;
    } 
    
    # over quota
    return 1;
}

#################################################################################
# error_exit - print message to STDERR and exit with error
# 
# Inputs
#    1: message to print to STDERR
# Returns
#    Nothing (never returns)
#################################################################################
sub error_exit {
    my $message = shift;
    die "Error: $message\n";
}

#################################################################################
# error_exit_usage - print message and usage to STDERR,  and exit with error (1)
# 
# Inputs
#    1: message to print to STDERR
#    2: command whose usage should be printed
# Returns
#    Nothing (never returns)
#################################################################################
sub error_exit_usage {
    my $message = shift;
    my $command = shift || "";
    
    my $sections = [ qw(SYNOPSIS ARGUMENTS OPTIONS) ];
    if ($command ne "") {
	$sections = [ "$command/SYNOPSIS", "$command/ARGUMENTS", "$command/OPTIONS" ];
    }
    
    pod2usage({
	-noperldoc => 1,
	-message => "Error: $message\n",
	-exitval => 1,
	-output => ">&STDERR",
	-verbose => 99,
	-sections => $sections,
	      });
    
    # this should not be reached, but call it in case something goes wrong with pod2usage
    error_exit($message);
}

#################################################################################
# exit_usage - print message to STDOUT, print usage, and exit successfully
# 
# Inputs
#    1: message to print to STDOUT
#    2: command whose usage should be printed
# Returns
#    Nothing (never returns)
#################################################################################
sub exit_usage {
    my $message = shift;
    my $command = shift || "";
    
    my $sections = [ qw(SYNOPSIS ARGUMENTS OPTIONS) ];
    if ($command ne "") {
	$sections = [ "$command/SYNOPSIS", "$command/ARGUMENTS", "$command/OPTIONS" ];
    }
    
    pod2usage({
	-noperldoc => 1,
	-message => "$message\n",
	-exitval => 0,
	-output => ">&STDOUT",
	-verbose => 99,
	-sections => $sections,
	      });

    # this should not be reached, but call it in case something goes wrong with pod2usage
    error_exit($message);
}

#################################################################################
# exit_full_help - print full perldocs to STDOUT and exit successfully
# 
# Inputs
#    None
# Returns
#    Nothing (never returns)
#################################################################################
sub exit_full_help {
    pod2usage({
	-noperldoc => 1,
	-verbose => 2,
	-message => "Displaying full help:\n",
	-exitval => 0,
	-output => ">&STDOUT",
	      });
    
    # this should not be reached, but call it in case something goes wrong with pod2usage
    error_exit("exit_full_help reached end unexpectedly");
}

#################################################################################
# exec_lfs - call the lfs binary 
# 
# all calls to external lfs binary should go through this subroutine.
# it completely drops the environment before exec'ing and uses the multiple-
# argument form of exec so that the shell will not be invoked.
# this routine never returns (execution passes to the external process or it 
# exits with an error)
# 
# Inputs
#    1: path to lfs binary
#    2: array of lfs command line args
# Returns
#    Nothing (never returns)
#################################################################################
sub exec_lfs {
    my $lfs_bin = shift;
    my @lfs_args = @_;

    # completely squash environment before exec
    %ENV = ();

    # call exec and never return (unless command is not found)
    # uses multiple-argument form of exec so that the shell is not invoked
    exec { $lfs_bin } $lfs_bin, @lfs_args or error_exit("couldn't exec $lfs_bin");
    
    error_exit("unexpectedly reached end of exec_lfs");
}


#################################################################################
# exec_lfs_pipe_open - return results from calling lfs binary
# 
# fork a child process and calls exec_lfs, returning a filehandle to read STDOUT 
# from the command.
# 
# Inputs
#    1: path to lfs binary
#    2: array of lfs command line args
# Returns
#    Filehandle to read from STDOUT of the lfs command
#################################################################################
sub exec_lfs_pipe_open {
    my $lfs_bin = shift;
    my @lfs_args = @_;
    
    # this code adapted from "safe pipe open for reading" 
    # described in: http://perldoc.perl.org/perlipc.html#Safe-Pipe-Opens
    my $child_stdout_fh;
    my $pid = open($child_stdout_fh, "-|");
    defined($pid) or error_exit("can't fork: $!");
    
    if (!$pid) { # $pid is only set in parent
	# child, call exec and never return (exec_lfs will exit on error)
	exec_lfs($lfs_bin, @lfs_args);
	
	# as a safety precaution, force child to exit (this should never be reached)
	error_exit("child process attempted to continue after exec_lfs");
    } else { 
        # parent, process data from child
	return $child_stdout_fh;
    }

    # this point should not be reached
    error_exit("unexpected error in exec_lfs_pipe_open");
}


#################################################################################
# lfs_get_quota - gets all quota data for a user or group and returns it
# 
# Fills a quota hash with keys for each of the quota limits:
# "size-hardlimit" (Bytes), "inode-hardlimit" (inode count)
# "size-softlimit" (Bytes), "inode-softlimit" (inode count)
# 
# As well as how much is currently in use and remaining:
# "size-used" (Bytes), "inode-used" (inode count)
# "size-remaining" (Bytes), "inode-remaining" (inode count)
# "size-overquota", "inode-overquota" (both "*" if over, "" if not)
# 
# And the grace period remaining since soft quota has been exceeded:
# "size-grace", "inode-grace" (both in seconds)
# 
# And finally some metadata regarding to what the quota pertains: 
# "filesystem" (lustre filesystem)
# "type" ("user"|"group")
# "name" (<user_name>|<group_name>)
# "timestamp" (timestamp in ISO8601 format)
# 
# Inputs
#    1: path to lfs binary
#    2: lustre filesystem
#    3: "user"|"group"
#    4: <user_name>|<group_name>
# Returns
#    Hashref to quota with units in Bytes (not kB), inodes, and seconds
#################################################################################
sub lfs_get_quota {
    my $lfs_bin = shift;    # 1: path to lfs binary
    my $filesystem = shift; # 2: lustre filesystem mount point
    my $quota_type = shift; # 3: "user" or "group"
    my $quota_name = shift; # 4: user or group name

    # validate arguments and untaint
    valid_abs_path($filesystem) or error_exit("get_quota: filesystem $filesystem not valid");
    $filesystem =~ m/^(\/.*)$/;
    $filesystem = $1;
    $quota_name =~ m/^([0-9]+|[a-z_][a-z0-9_-]{0,31})$/ or error_exit("get_quota: user/group name $quota_name not valid");
    $quota_name = $1;
    
    my $lfs_quota_out_fh;
    if ($quota_type eq "user") {
	$lfs_quota_out_fh = exec_lfs_pipe_open($lfs_bin, "quota", "-u", $quota_name, $filesystem);
    } elsif ($quota_type eq "group") {
	$lfs_quota_out_fh = exec_lfs_pipe_open($lfs_bin, "quota", "-g", $quota_name, $filesystem);
    } else {
	error_exit("unexpected value for quota type: $quota_type");
    
    }

    my %quota;
    $quota{"filesystem"} = $filesystem;
    $quota{"type"} = $quota_type;
    $quota{"name"} = $quota_name;
    
    my $usergroupline = <$lfs_quota_out_fh>;
    defined($usergroupline) or error_exit("no output from lfs quota for $filesystem $quota_type $quota_name");
    chomp $usergroupline;
    my $usergroupname = "";
    my $ugid = -1;
    if ($quota_type eq 'user') {
	$usergroupline =~ m/user\s(\S+)/ or error_exit("could not find user in lfs quota output for $filesystem $quota_type $quota_name");
	$usergroupname = $1;
	$usergroupline =~ m/uid\s([0-9]+)/ or error_exit("could not find uid in lfs quota output for $filesystem $quota_type $quota_name");
	$ugid = $1;
    } elsif ($quota_type eq 'group') {
	$usergroupline =~ m/group\s(\S+)/ or error_exit("could not find group in lfs quota output for $filesystem $quota_type $quota_name");
	$usergroupname = $1;
	$usergroupline =~ m/gid\s([0-9]+)/ or error_exit("could not find gid in lfs quota output for $filesystem $quota_type $quota_name");
	$ugid = $1;
    } else {
	error_exit("invalid quota_type $quota_type in lfs_get_quota for $filesystem $quota_type $quota_name");
    }
    
    my $headerline = <$lfs_quota_out_fh>;
    chomp $headerline;
    $headerline =~ m/kbytes\s+quota\s+limit\s+grace\s+files\s+quota\s+limit\s+grace\s*$/ or error_exit("unexpected header in output from lfs quota for $filesystem $quota_type $quota_name: [$headerline]");
    
    my $fsline = <$lfs_quota_out_fh>;
    chomp $fsline;
    $fsline =~ m/^\s*$filesystem\s*$/ or error_exit("unexpected filesystem reported from lfs quota: $fsline (expecting: $filesystem)");
    
    my $quotaline = <$lfs_quota_out_fh>;
    chomp $quotaline;
    $quotaline =~ m/([0-9-]+)([*]?) # $1, $2 - size used in blocks followed by '*' if over quota
                        \s+             
                        ([0-9-]+|$LFS_QUOTA_SIZE_UNLIMITED)       # $3 - size soft limit in blocks
                        \s+
                        ([0-9-]+)       # $4 - size hard limit in blocks
                        \s+
                        (\S+|$LFS_GRACE_INACTIVE)           # $5 - block grace time remaining
                        \s+
                        ([0-9-]+)([*]?) # $6, $7 - inodes used followed by '*' if over quota
                        \s+
                        ([0-9-]+)       # $8 - inode soft limit
                        \s+
                        ([0-9-]+)       # $9 - inode hard limit
                        \s+
                        (\S+|$LFS_GRACE_INACTIVE)           # $10 - inode grace time remaining
                        \s*
                        $/x or error_exit("unexpected data in output from lfs quota for $filesystem $quota_type $quota_name: [$quotaline]");
    # post-process into standard units (bytes, inodes, seconds)
    $quota{"size-used"} = lfs_blocks_used_to_bytes($1);
    $quota{"size-overquota"} = $2;
    $quota{"size-softlimit"} = lfs_block_limit_to_bytes($3);
    $quota{"size-hardlimit"} = lfs_block_limit_to_bytes($4);
    $quota{"size-grace"} = lfs_grace_time_to_seconds($5);
    $quota{"inode-used"} = $6; 
    $quota{"inode-overquota"} = $7;
    $quota{"inode-softlimit"} = lfs_process_inode_limit_in($8);
    $quota{"inode-hardlimit"} = lfs_process_inode_limit_in($9);
    $quota{"inode-grace"} = lfs_grace_time_to_seconds($10);
    
    # record timestamp along with the data
    $quota{"timestamp"} = DateTime->now()->iso8601();
    
    # calculate remaining if there is a quota set
    my @size_quotas = grep(!/^$NO_QUOTA$/, $quota{"size-softlimit"}, $quota{"size-hardlimit"});
    $quota{"size-remaining"} = (@size_quotas > 0) ? (min(@size_quotas) - $quota{"size-used"}) : $NO_QUOTA;
    my @inode_quotas = grep(!/^$NO_QUOTA$/, $quota{"inode-softlimit"}, $quota{"inode-hardlimit"});
    $quota{"inode-remaining"} = (@inode_quotas > 0) ? (min(@inode_quotas) - $quota{"inode-used"}) : $NO_QUOTA;
    
    # shouldn't be any more output - if there is, signal an error
    while(my $emptyline = <$lfs_quota_out_fh>) {
	chomp $emptyline;
	$emptyline =~ m/^\s*$/ or error_exit("unexpected additional output from lfs quota for $filesystem $quota_type $quota_name: $emptyline");
    }
    
    close($lfs_quota_out_fh) or error_exit("lfs quota failed for $filesystem $quota_type $quota_name: $!");
    
    return \%quota;
}


#################################################################################
# lfs_set_quota - sets quota for a user or group and returns on success
# Inputs
#    1: path to lfs binary
#    2: lustre filesystem
#    3: "user"|"group"
#    4: <user_name>|<group_name>
#    5: hashref to quota hash containing at least one of:
#       "size-hardlimit", "size-softlimit", "inode-hardlimit", "inode-softlimit"
# Returns
#    1 on success, undef on failure
#################################################################################
sub lfs_set_quota {
    my $lfs_bin = shift;    # 1: path to lfs binary
    my $filesystem = shift; # 2: lustre filesysteam
    my $quota_type = shift; # 3: "user" or "group"
    my $quota_name = shift; # 4: user or group name
    my $new_quota = shift;  # 5: hashref for quota to set

    # validate arguments and untaint
    valid_abs_path($filesystem) or error_exit("set_quota: filesystem $filesystem not valid");
    $filesystem =~ m/^(\/.*)$/;
    $filesystem = $1;
    $quota_name =~ m/^([0-9]+|[a-z_][a-z0-9_-]{0,31})$/ or error_exit("set_quota: user/group name $quota_name not valid");
    $quota_name = $1;

    my @lfs_args;
    push @lfs_args, "setquota";
    
    my $uorg;
    if ($quota_type eq 'user') {
	$uorg = "-u";
    } elsif ($quota_type eq 'group') {
	$uorg = "-g";
    } else {
	error_exit("invalid quota_type $quota_type in lfs_set_quota for $filesystem $quota_type $quota_name");
    }
    push @lfs_args, $uorg, $quota_name;

    if (defined($new_quota->{"size-softlimit"})) { 
	push @lfs_args, "--block-softlimit", lfs_bytes_to_block_limit($new_quota->{"size-softlimit"});
    }
    if (defined($new_quota->{"size-hardlimit"})) {
	push @lfs_args, "--block-hardlimit", lfs_bytes_to_block_limit($new_quota->{"size-hardlimit"});
    }
    if (defined($new_quota->{"inode-softlimit"})) {
	push @lfs_args, "--inode-softlimit", lfs_process_outode_limit_out($new_quota->{"inode-softlimit"});
    }
    if (defined($new_quota->{"inode-hardlimit"})) {
	push @lfs_args, "--inode-hardlimit", lfs_process_outode_limit_out($new_quota->{"inode-hardlimit"});
    }
    push @lfs_args, $filesystem;
    my $lfs_setquota_out_fh = exec_lfs_pipe_open($lfs_bin, @lfs_args);
    
    close($lfs_setquota_out_fh) or error_exit("lfs setquota failed for $filesystem $quota_type $quota_name");
    return (($?>>8) ? undef : 1);
}

#################################################################################
# lfs_process_inode_limit_in - process inode limits reported by lfs command
# 
# Inputs
#    1: inode count as output by lfs command
# Returns
#    inode count or $NO_QUOTA if unlimited
#################################################################################
sub lfs_process_inode_limit_in {
    my $inode_count = shift;
    
    if ($inode_count =~ m/^$LFS_QUOTA_INODE_UNLIMITED$/) {
        return $NO_QUOTA;
    } else {
	return $inode_count;
    }
}

#################################################################################
# lfs_process_inode_limit_out - process internal inode limits to those suited 
# for lfs command
# 
# Inputs
#    1: inode limit
# Returns
#    inode limit or $LFS_QUOTA_INODE_UNLIMITED if unlimited
#################################################################################
sub lfs_process_outode_limit_out {
    my $inode_count = shift;
    
    if ($inode_count =~ m/^$NO_QUOTA$/) {
	return $LFS_QUOTA_INODE_UNLIMITED;
    } else {
	return $inode_count;
    }
}

#################################################################################
# lfs_block_limit_to_bytes - convert block limit reported by lfs command to bytes
# 
# Inputs
#    1: block limit as output by lfs command
# Returns
#    limit in bytes or $NO_QUOTA if unlimited
#################################################################################
sub lfs_block_limit_to_bytes {
    my $blocks = shift;
    my $bytes = 0;

    if ($blocks =~ m/^$LFS_QUOTA_SIZE_UNLIMITED$/) {
	$bytes = $NO_QUOTA;
    } else {
	$bytes = $blocks * $LFS_BLOCKSIZE;
    }
    
    return $bytes;
}

#################################################################################
# lfs_bytes_to_block_limit - convert bytes to block limit for lfs command
# 
# Inputs
#    1:bytes
# Returns
#    limit in blocks (or $LFS_QUOTA_SIZE_UNLIMITED if unlimited)
#################################################################################
sub lfs_bytes_to_block_limit {
    my $bytes = shift;
    my $blocks = 0;
    
    if ($bytes =~ m/^$NO_QUOTA$/) {
	$blocks = $LFS_QUOTA_SIZE_UNLIMITED;
    } else {
	$blocks = sprintf("%d", ($bytes / $LFS_BLOCKSIZE));
    }
    
    return $blocks;
}

#################################################################################
# lfs_blocks_used_to_bytes - convert blocks used reported by lfs command to bytes
# 
# Inputs
#    1: blocks used as output by lfs command
# Returns
#    bytes used or $NO_QUOTA if unlimited
#################################################################################
sub lfs_blocks_used_to_bytes {
    my $blocks = shift;
    
    return ($blocks * $LFS_BLOCKSIZE);
}

#################################################################################
# lfs_grace_time_to_seconds - convert grace time reported by lfs command to sec.
# 
# Inputs
#    1: grace time as output by lfs command
# Returns
#    grace time in seconds or $NO_QUOTA if unlimited
#################################################################################
sub lfs_grace_time_to_seconds {
    my $gracetime = shift;
    my $seconds = 0;
    
    # gracetime can be in seconds already or can be something like: "6d23h59m50s"
    if ($gracetime =~ m/^$LFS_GRACE_INACTIVE$/) {
	$seconds = $TIMER_INACTIVE;
    } elsif ($gracetime =~ m/[dhms]/) {
	# process in d h m s format
	$gracetime =~ m/^([0-9]*)d?([0-9]*)h?([0-9]*)m?([0-9]*)s?/ or error_exit("lfs_process_grace_to_seconds: could not process gracetime: $gracetime");
    } elsif ($gracetime =~ m/^[0-9]+$/) {
	# process as s
	$seconds = $gracetime;
    }
    return $seconds;
}

#################################################################################
# check_quota_change - checks whether new quota would put old quota(s) over quota 
# that were not previously over quota
# 
# Inputs
#    1: ref to array of hashes of old quotas
#    2: ref to hash of new quota limits to check
# Returns
#    1 on success, exits process on failure
#################################################################################
sub check_quota_change {
    my $old_quotas = shift;
    my $new_quota = shift;
    
    foreach my $old_quota (@{$old_quotas}) {
	foreach my $limit_key (keys %{$new_quota}) {
	    $limit_key =~ m/^(size|inode)-(softlimit|hardlimit)$/ or error_exit("check_quota_change unrecognised limit $limit_key");
	    my $used_key = $1."-used";
	    if ( !over_quota($old_quota->{$limit_key}, $old_quota->{$used_key}) &&
		 over_quota($new_quota->{$limit_key}, $old_quota->{$used_key})) {
		error_exit($old_quota->{"type"}." ".$old_quota->{"name"}." is not currently over ".$limit_key." quota but new quota would put it over quota. if you meant to do this, retry with --force-".$limit_key." or increase $limit_key to at least ".convert_from_bytes_human($old_quota->{$used_key}));
	    }
	}
    }
    return 1;
}

#################################################################################
# output_quotas - print quotas (or subset of quota) in specified format and units
# 
# Inputs
#    1: ref to array of hashes of quotas to print
#    2: format ("json", "csv", "tsv", "spacesv", "dumper")
#    3: size units
#    4: inode units
#    5: time units
#    6: ref to array of columns to include (if not specified, include all)
# Returns
#    1 on success, exits process on failure
#################################################################################
sub output_quotas {
    my $quotas = shift;
    my $format = shift || "tsv";
    my $size_units = shift; 
    my $inode_units = shift; 
    my $time_units = shift; 
    my $columns = shift;

    my $unitquotas;
    foreach my $type (keys %{$quotas}) {
	foreach my $name (keys %{$quotas->{$type}}) {
	    my $quota = $quotas->{$type}->{$name};
	    error_exit("output_quotas: type did not match for $type/$name") unless $quota->{"type"} eq $type;
	    error_exit("output_quotas: name did not match for $type/$name") unless $quota->{"name"} eq $name;
	    foreach my $key (keys %{$quota}) {
		if ($key =~ m/^size-(used|softlimit|hardlimit|remaining)$/ && $quota->{$key} =~ m/^[0-9]+$/) {
		    $unitquotas->{$type}{$name}{$key} = convert_from_bytes($quota->{$key}, $size_units);
		} elsif ($key =~ m/^inode-(used|softlimit|hardlimit|remaining)$/ && $quota->{$key} =~ m/^[0-9]+$/) {
		    $unitquotas->{$type}{$name}{$key} = convert_from_inodes($quota->{$key}, $inode_units);
		} elsif ($key =~ m/-grace$/ && $quota->{$key} =~ m/^[0-9]+$/) {
		    $unitquotas->{$type}{$name}{$key} = convert_from_seconds($quota->{$key}, $time_units);
		} else {
		    $unitquotas->{$type}{$name}{$key} = $quota->{$key};
		}
	    }
	}
    }
    
    if (lc($format) =~ m/^(json|dumper)$/) {
	my $subset_quotas;
	if (@{$columns} > 0) {
	    foreach my $col (@{$columns}) {
		foreach my $type (keys %{$unitquotas}) {
		    foreach my $name (keys %{$unitquotas->{$type}}) {
			$subset_quotas->{$type}{$name}{$col} = $unitquotas->{$type}{$name}{$col};
		    }
		}
	    }
	} else {
	    # include all columns in json output
	    $subset_quotas = $unitquotas;
	}
	if (lc($format) eq 'json') {
	    output_quotas_json($subset_quotas);
	} elsif (lc($format) eq 'dumper') {
	    output_quotas_dumper($subset_quotas);
	} else {
	    error_exit("output_quotas: unexpected value for format: [$format]");
	}
    } elsif (lc($format) =~ m/^(tsv|csv|spacesv)/) {
	my $field_sep = "\t";
	if ($format eq "csv") {
	    $field_sep = ",";
	} elsif ($format eq "spacesv") {
	    $field_sep = " ";
	}
	my $tablefmt = $1;
	if (@{$columns} > 0) {
	    output_quotas_table($unitquotas, $columns, $field_sep, "\n");
	} else {
	    output_quotas_table($unitquotas, $COLUMN_ORDER, $field_sep, "\n");
	}
    } else {
	error_exit("output_quotas: unsupported output format $format");
    }
    return 1;
}

#################################################################################
# output_quotas_json - print quotas array as JSON
# 
# Inputs
#    1: ref to hash (on <type>) of hashes (on <name>) of hashes of quotas to print
# Returns
#    1 on success, exits process on failure
#################################################################################
sub output_quotas_json {
    my $quotas = shift;
    print JSON::XS->new->pretty(1)->encode($quotas)."\n" or error_exit("output_quotas_json could not encode JSON: $!");
    return 1;
}

#################################################################################
# output_quotas_dumper - print quotas array as Data::Dumper serialised object
# 
# Inputs
#    1: ref to hash (on <type>) of hashes (on <name>) of hashes of quotas to print
# Returns
#    1 on success, exits process on failure
#################################################################################
sub output_quotas_dumper {
    my $quotas = shift;
    my $dumper = Data::Dumper->new([]);
    $dumper->Terse(1);
    $dumper->Values([$quotas]);
    print $dumper->Dump()."\n" or error_exit("output_quotas_dumper could not output quotas: $!");
    return 1;
}

#################################################################################
# output_quotas_table - print quotas array as table with given field and row seps
# 
# Inputs
#    1: ref to array of hashes of quotas to print
#    2: ref to array of columns to print 
#    3: field separator (optional: default "\t")
#    4: row separator (optional: default "\n")
# Returns
#    1 on success, exits process on failure
#################################################################################
sub output_quotas_table {
    my $quotas = shift;
    my $columns = shift;
    my $field_sep = shift || "\t";
    my $row_sep = shift || "\n";

    print join($field_sep, @{$columns}).$row_sep;
    foreach my $type (keys %{$quotas}) {
	foreach my $name (keys %{$quotas->{$type}}) {
	    my $quota = $quotas->{$type}->{$name};
	    error_exit("output_quotas: type did not match for $type/$name") unless $quota->{"type"} eq $type;
	    error_exit("output_quotas: name did not match for $type/$name") unless $quota->{"name"} eq $name;
	    print join($field_sep, map {$quota->{$_}} @{$columns}).$row_sep;
	}
    }
}

#################################################################################
# convert_from_bytes - convert bytes to formatted units
# 
# Inputs
#    1: bytes
#    2: units
# Returns
#    formatted string including units
#################################################################################
sub convert_from_bytes {
    my $bytes = shift;
    my $units = shift || "";
    if ( (!$units) || $units eq 'B') {
	return $bytes.$OUTPUT_UNIT_SEP.$units;
    } elsif ($units eq 'human_binary') {
	return convert_from_bytes_human($bytes, 0);
    } elsif ($units eq 'human_decimal') {
	return convert_from_bytes_human($bytes, 1);
    } elsif ($units ne 'B') {
	# fixed unit specification requiring conversion
	for (my $i=1; $i<@{$BINARY_UNIT_LABELS}; $i++) {
	    if ($BINARY_UNIT_LABELS->[$i] eq $units) {
		return sprintf("%.1f%s%s", ($bytes / (1024 ** $i)), $OUTPUT_UNIT_SEP, $units);
	    }
	    if ($DECIMAL_UNIT_LABELS->[$i] eq $units) {
		return sprintf("%.1f%s%s", ($bytes / (1000 ** $i)), $OUTPUT_UNIT_SEP, $units);
	    }
	}
    }
    error_exit("unknown size units [$units]. specify one of: ".join(', ', @{$BINARY_UNIT_LABELS}, @{$DECIMAL_UNIT_LABELS}, 'human_binary', 'human_decimal'));
}

#################################################################################
# convert_to_bytes - convert from formatted units to bytes
# 
# Inputs
#    1: formatted string with value and units (e.g. "1.5TiB")
# Returns
#    bytes
#################################################################################
sub convert_to_bytes {
    my $formatted = shift;
    
    $formatted =~ m/^([0-9]+([.][0-9]+)?)[[:space:]]*((B|KiB|MiB|GiB|TiB|PiB|EiB|ZiB|YiB|kB|MB|GB|TB|PB|EB|ZB|YB){0,1})$/ or error_exit("convert_to_bytes: malformatted string [$formatted]");
    
    my $value = $1;
    my $units = $3 || "B";
    
    # fixed unit specification requiring conversion
    for (my $i=0; $i<@{$BINARY_UNIT_LABELS}; $i++) {
	if ($BINARY_UNIT_LABELS->[$i] eq $units) {
	    return sprintf("%d", ($value * (1024 ** $i)));
	}
	if ($DECIMAL_UNIT_LABELS->[$i] eq $units) {
	    return sprintf("%d", ($value * (1000 ** $i)));
	}
    }
    
    error_exit("unknown size units [$units]. specify one of: ".join(', ', @{$BINARY_UNIT_LABELS}, @{$DECIMAL_UNIT_LABELS}));
}


#################################################################################
# convert_from_inodes - convert inode count to formatted units
# 
# Inputs
#    1: inode count
#    2: units
# Returns
#    formatted string including units
#################################################################################
sub convert_from_inodes {
    my $inodes = shift;
    my $units = shift;
    if (!$units) {
	return $inodes;
    } else {
	if ($units eq 'human') {
	    return convert_from_inodes_human($inodes);
	} else {
	    # fixed unit specification
	    for (my $i=1; $i<@{$DECIMAL_PREFIXES}; $i++) {
		if ($DECIMAL_PREFIXES->[$i] eq $units) { 
		    return sprintf("%.1f%s%s", ($inodes / (1024 ** $i)), $OUTPUT_UNIT_SEP, $units);
		}
	    }
	}
	error_exit("unknown inode units [$units]. specify one of: ".join(', ', @{$DECIMAL_PREFIXES}, 'human'));
    } 
} 

#################################################################################
# convert_to_inodes - convert from formatted units to inodes
# 
# Inputs
#    1: formatted string with value and units (e.g. "1.5M" for 1500000)
# Returns
#    inodes
#################################################################################
sub convert_to_inodes {
    my $formatted = shift;
    
    $formatted =~ m/^([0-9]+([.][0-9]+)?)[[:space:]]*((k|M|G|T|P|E|Z|Y){0,1})$/ or error_exit("convert_to_inodes: malformatted string [$formatted]");
    
    my $value = $1;
    my $units = $3 || "";

    # fixed unit specification requiring conversion
    for (my $i=0; $i<@{$DECIMAL_PREFIXES}; $i++) {
	if ($DECIMAL_PREFIXES->[$i] eq $units) {
	    return sprintf("%d", ($value * (1000 ** $i)));
	}
    }
    
    error_exit("unknown size units [$units]. specify one of: ".join(', ', @{$DECIMAL_PREFIXES}));
}


#################################################################################
# convert_from_seconds - convert seconds to formatted units
# 
# Inputs
#    1: seconds
#    2: units
# Returns
#    formatted string including units
#################################################################################
sub convert_from_seconds {
    my $gracetime = shift;
    my $units = shift;
    if ( (!$units) || $units eq 's') {
	return $gracetime.$OUTPUT_UNIT_SEP.$units;
    } elsif ($units eq 'human') {
	return convert_from_seconds_human($gracetime);
    } else {
	# fixed unit specification
	for (my $i=1; $i<@{$TIME_UNIT_LABELS}; $i++) {
	    if ($TIME_UNIT_LABELS->[$i] eq $units) {
		return sprintf("%.1f%s%s", ($gracetime / $TIME_UNIT_RATIOS->[$i]), $OUTPUT_UNIT_SEP, $units);
	    }
	}
    }
    error_exit("unknown gracetime units [$units]. specify one of: ".join(', ', @{$TIME_UNIT_LABELS}, 'human'));
} 

#################################################################################
# convert_from_bytes_human - convert bytes to human-readable units
# 
# Inputs
#    1: bytes
#    2: "1" for decimal units ("kB","MB",etc), "0" for binary units ("KiB","MiB",etc)
# Returns
#    formatted string including units
#################################################################################
sub convert_from_bytes_human {
    my $bytes = shift;
    my $decimal = shift;
    
    my $base = 1024;
    my @labels = @{$BINARY_UNIT_LABELS};
    if($decimal) {
	$base = 1000;
	@labels = @{$DECIMAL_UNIT_LABELS};
    }
    
    my $unit_index = 0;
    TESTUNIT: while($unit_index < $#labels) { # only need to test n-1 as we'll stay in the final unit
	my $unitmax = ($base ** ($unit_index+1)) * $HUMAN_TRIGGER_RATIO;
	if ($bytes < $unitmax) {
	    # we fit in this one, stop here
	    last TESTUNIT;
	}
	$unit_index++;
    }
    
    return sprintf("%.1f%s%s", $bytes / ($base ** $unit_index), $OUTPUT_UNIT_SEP, $labels[$unit_index]);
}

#################################################################################
# convert_from_inodes_human - convert inode count to human-readable units
# 
# Inputs
#    1: inode count
# Returns
#    formatted string including units
#################################################################################
sub convert_from_inodes_human {
    my $count = shift;
    
    my $base = 1000;
    my @labels = @{$DECIMAL_PREFIXES};
    
    my $unit_index = 0;
    TESTUNIT: while($unit_index < $#labels) { # only need to test n-1 as we'll stay in the final unit
	my $unitmax = ($base ** ($unit_index+1)) * $HUMAN_TRIGGER_RATIO;
	if ($count < $unitmax) {
	    # we fit in this one, stop here
	    last TESTUNIT;
	}
	$unit_index++;
    }
    
    return sprintf("%.1f%s%s", $count / ($base ** $unit_index), $OUTPUT_UNIT_SEP, $labels[$unit_index]);
}

#################################################################################
# convert_from_seconds_human - convert seconds to human-readable units
# 
# Inputs
#    1: time in seconds 
# Returns
#    formatted string including units
#################################################################################
sub convert_from_seconds_human {
    my $seconds = shift;
    
    my $result = "";
    my $remaining = $seconds;
    # convert to ywdhms format (only including the largest non-zero)
    for (my $i=@{$TIME_UNIT_RATIOS}-1; $i>0; $i--) {
	if ( ($seconds / $TIME_UNIT_RATIOS->[$i]) > 1) {
	    # include the i-th part in output
	    my $part = int($remaining / $TIME_UNIT_RATIOS->[$i]);
	    $result .= $part.$TIME_UNIT_LABELS->[$i];
	    $remaining -= $part * $TIME_UNIT_RATIOS->[$i];
	}
    }
    # add in the remaining seconds (0th unit)
    $result .= $remaining.$TIME_UNIT_LABELS->[0];

    return $result;
}


__END__

=head1 DESCRIPTION

A wrapper script for portions of the I<lfs> command distributed with the
Lustre filesystem (L<http://lustre.org/>). Currently wraps up the functionality
of the quota, setquota, and find commands.

It takes as its first argument the mount point of a Lustre filesystem and
will only allow lfs commands to run against that filesystem. It is intended
with use along with sudo, as the sudoers file can specify that individual
users or groups can run this wrapper script against a limited set of Lustre
filesystems specifically listed.


=head1 CONFIGURATION AND ENVIRONMENT

This script is intended to be called using sudo, so for security reasons it 
does not have any external configuration files or environment variables.

In fact, it does not allow dependencies to be loaded from F<.> or from a 
PERL5LIB directory, and when calling lfs it eliminates all environment 
variables. 

You can configure Lustre operators to be able to run this command as root by 
adding an appropriate line to the F</etc/sudoers> file listing the full path 
to this script, followed by the path to the lfs binary (it would be wise 
to ensure that path is actually an lfs binary and not a root exploit and that 
it is not writable by unauthorised users), and optionally followed by the mount 
point of the Lustre file system for which they are allowed to act as operator.  
If you leave off the filesystem from the sudoers rule, the user would be able 
to administer any filesystem. 

For example:
C<user1 ALL = (root) NOPASSWD : /usr/local/bin/lustre_operator /usr/bin/lfs /mnt/lustre1, \
                              /usr/local/bin/lustre_operator /usr/bin/lfs /mnt/lustre2>


=head1 DEPENDENCIES

=over 

=item Lustre I<lfs> command 

=item L<Getopt::Long> (from CPAN)

=item L<Pod::Usage> (from CPAN)

=back


=head1 INCOMPATIBILITIES

May not work with older versions of the lfs command (Lustre < 1.8), as
this has not been tested. 


=head1 BUGS AND LIMITATIONS

There are no known bugs in this program. 

Please report problems to L<mailto:hgi@sanger.ac.uk>

Patches/pull requests are welcome. 

Development is hosted on github: L<https://github.com/wtsi-hgi/lustre_operator>


=head1 AUTHOR

Joshua C. Randall (jcrandall@alum.mit.edu)


=head1 LICENCE AND COPYRIGHT

Copyright (c) 2013 Genome Research Ltd.

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along with
this program. If not, see <http://www.gnu.org/licenses/>.

=cut







