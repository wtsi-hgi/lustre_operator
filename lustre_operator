#!/usr/bin/perl -T 
#################################################################################
#
# Copyright (c) 2013 Genome Research Ltd.
# 
# Author: Joshua C. Randall <jcrandall@alum.mit.edu>
# 
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <http://www.gnu.org/licenses/>.
# 
#################################################################################

use strict;
use warnings;
use 5.008_008;

package lustre_operator;


#################################################################################
# In taint mode, '.' is removed from @INC and PERL5LIB is ignored so we can 
# safely depend on only getting modules from only directories compiled into perl
# (see http://perldoc.perl.org/perlsec.html#Taint-mode-and-@INC)
# 
# This means all of the below modules MUST be located in the system PERL5LIB --
# this is intentional for the security of this script. 
#################################################################################
use Getopt::Long qw(GetOptionsFromArray :config posix_default no_ignore_case);
use Pod::Usage;
use DateTime;
use List::Util qw(min);
use JSON::XS;
use Data::Dumper;

#################################################################################
# Configuration
#################################################################################

# the block size that Lustre uses to set and report quota (in Bytes)
my $LFS_BLOCKSIZE      = 1024; 

# the value lfs reports when quota grace time is not active (e.g. not over soft)
my $LFS_GRACE_INACTIVE = "-";

# the value lfs reports when size quota is unlimited
my $LFS_QUOTA_SIZE_UNLIMITED = 0;

# the value lfs reports when inode count quota is unlimited
my $LFS_QUOTA_INODE_UNLIMITED = 0;

# what value to set for minimal size quota
my $LFS_QUOTA_SIZE_MIN = 1;

# what value to set for minimal inode quota
my $LFS_QUOTA_INODE_MIN = 1;

# what value to use if no quota limit is set 
my $NO_QUOTA	       = "unlimited";

# what value to report if grace periods are not active
my $TIMER_INACTIVE     = "inactive";

# regular expression matching illegal filename/path characters
my $ILLEGAL_PATH_REGEX = qr/[\|\\\012\r\n\t\013\*\"\?\<\:\>]/; 

# binary SI units labels from bytes to yobibytes
my $BINARY_UNIT_LABELS  = ["B","KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"];

# decimal SI unit labels from bytes to yottabytes
my $DECIMAL_UNIT_LABELS = ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];

# time unit labels from seconds to years
my $TIME_UNIT_LABELS = ["s", "m",  "h",   "d",    "w",      "y"];
my $TIME_UNIT_RATIOS = [  1,  60, 3600, 86400, 604800, 31536000];

# for unitless inode counts
my $DECIMAL_PREFIXES = ["", "k", "M", "G", "T", "P", "E", "Z", "Y"];

# ratio of the next unit value at which to switch to it 
# (e.g. 0.8 implies we would say "0.8 kB" instead of "800 B" 
# whereas 1.2 would mean we would say "1199 B" but "1.2 kB" instead of "1200 B")
my $HUMAN_TRIGGER_RATIO = 0.8;

# the order of output columns in table output
my $COLUMN_ORDER = ["filesystem","type","name","size-used","size-softlimit","size-hardlimit","size-remaining","size-grace","inode-used","inode-softlimit","inode-hardlimit","inode-remaining","inode-grace","timestamp"];

# separator between value and units in output
my $OUTPUT_UNIT_SEP = "";


#################################################################################
# If run as a script (rather than used or required from elsewhere), pass 
# command-line arguments to run. 
#################################################################################
lustre_operator::run(@ARGV) unless caller();


=head1 NAME

lustre_operator - a wrapper script for Lustre's 
lfs command suitable for sudo use.

=head1 GENERAL

=head2 SYNOPSIS

lustre_operator B<<lfs_binary>> B<<lustre_filesystem>> B<<command>> [B<<options>>]

Supports the C<getquota>, C<setquota>, and C<find> lfs commands.

=head2 ARGUMENTS

=over

=item B<lfs_binary>

An absolute path to the lfs binary.

=item B<lustre_filesystem>

An absolute path to the lustre filesystem mount point, as specified 
in F</proc/mounts> and/or F</etc/mtab> (and reported by I<mount>).

=item B<command>

Command (C<getquota>, C<setquota>, or C<find>) to run.

=back

=head2 OPTIONS

=over

=item [--help|-?]

=back

=head1 GETQUOTA

=head2 SYNOPSIS

lustre_operator B<<lfs_binary>> B<<lustre_filesystem>> getquota [B<<options>>]

=head2 OPTIONS

=over

=item [--user|-u <<uname>>|<<uid>>]

username or uid for a user whose quota you wish to report 
(you can specify this option multiple times)

=item [--group|-g <<gname>>|<<gid>>]

group name or gid for a group whose quota you wish to report 
(you can specify this option multiple times)

=item [--human|-h]

use human readable units
(synonym for C<--size-units human_binary --inode-units human --time-units human>)

=item [--human_decimal|-d]

use decimal (kB=1000^1, MB=1000^2, GB=1000^3, ...) rather 
than binary (KiB=1024^1, MiB=1024^2, GiB=1024^3, ...) size units 
for human readable output (synonym for 
C<--size-units human_decimal --inode-units human --time-units human>)

overrides --human

=item [--size-units|-s] <<size_units>>

use specified units for size. <<size_units>> can be: ""|"B"|"kB"|"KiB"|"MB"|"MiB"|"GB"|"GiB"|"TB"|"TiB"|"PB"|"PiB"|"EB"|"EiB"|"ZB"|"ZiB"|"YB"|"YiB"|"human_binary"|"human_decimal"

the default is <<size_units>>="B"

=item [--inode-units|-i] <<inode_units>>

use specified units for inode count. <<inode_units>> can be: ""|"k"|"M"|"G"|"T"|"P"|"E"|"Z"|"Y"|"human"

the default is <<inode_units>>=""

=item [--time-units|-t] <<time_units>>

use specified units for grace time. <<time_units>> can be: ""|"s"|"m"|"h"|"d"|"w"|"y"|"human"

the default is <<time_units>>="s"

=item [--format|-f] <<format>>

specify output format. <<format>> can be: "json"|"csv"|"tsv"|"spacesv"|"dumper"

=item [--column|-c] <<column_header>>

select a column to include in output instead of the default of all columns 
if none of these options are given

can be specified multiple times in which case all specified columns are included 
and order is preserved (as listed on the command line). 

=back

=head2 EXAMPLES

=over

=item get quota information for the current user and group on /mnt/lustre1:

C<lustre_operator /usr/bin/lfs /mnt/lustre1 getquota>

=item get quota information for user1 on /mnt/lustre1:

C<lustre_operator /usr/bin/lfs /mnt/lustre1 getquota --user user1>

=item get quota information for group1 on /mnt/lustre1:

C<lustre_operator /usr/bin/lfs /mnt/lustre1 getquota --group group1>

=back

=head1 SETQUOTA

=head2 SYNOPSIS

lustre_operator B<<lfs_binary>> B<<lustre_filesystem>> setquota 
-u|--user|-g|--group <<uname>>|<<uid>>|<<gname>>|<<gid>> [options]

=head2 OPTIONS

=over

=item -u|--user|-g|--group <<uname>>|<<uid>>|<<gname>>|<<gid>>

Specify user or group by either name or number. 

=back

=head2 OPTIONS

=over

=item [--size-softlimit|-b <<size-softlimit>>] 

=item [--force-size-softlimit]

=item [--size-hardlimit|-B <<size-hardlimit>>]

=item [--force-size-hardlimit]

=item [--inode-softlimit|-i <<inode-softlimit>>]

=item [--force-inode-softlimit]

=item [--inode-hardlimit|-I <<inode-hardlimit>>]

=item [--force-inode-hardlimit]

=back

=head2 EXAMPLES

=over

=item set the quota for user user2 on /mnt/lustre2 to 1 TebiByte 
(1024^4 bytes) and 1 million inodes (files):

C<lustre_operator /usr/bin/lfs /mnt/lustre1 setquota --user user2 
--size-hardlimit 1TiB  --inode-hardlimit 1M>

=item set the quota for group group2 on /mnt/lustre2 to 100 megabytes 
(100 * 1000^2 bytes) and 1500 inodes:

C<lustre_operator /usr/bin/lfs /mnt/lustre2 setquota --group group2 
--size-hardlimit 100MB --inode-hardlimit 1.5k>

=item set the quota for group group2 on /mnt/lustre2 to 1 block and 
1 inode (this is the minimum quota):

C<lustre_operator /usr/bin/lfs /mnt/lustre2 setquota --group group2 
--size-hardlimit 1 --inode-hardlimit 1>

=back

=head1 FIND

=head2 SYNOPSIS

lustre_operator B<<lfs_binary>> B<<lustre_filesystem>> find B<<dir>|<file>> [options]

=head2 ARGUMENTS

=over

=item B<<dir>|<file>>

Path from which to begin the recursive find.

=back

=head2 OPTIONS

=over

=item [[!] --atime|-A [+-]N]

=item [[!] --mtime|-M [+-]N]

=item [[!] --ctime|-C [+-]N]

=item [--maxdepth|-D N]

=item [[!] --name|-n <<pattern>>]

=item [--print0|-P]

=item [--print|-p]

=item [[!] --obd|-O <<uuid[s]>>]

=item [[!] --size|-s [+-]N[bkMGTP]]

=item [[!] --type|-t <<filetype>>]

=item [[!] --gid|-g|--group|-G <<gid>>|<<gname>>]

=item [[!] --uid|-u|--user|-U <<uid>>|<<uname>>]

=back

=head3 NOTES

=over

=item !: used before an option indicates 'NOT' the requested attribute

=item -: used before an value indicates 'AT MOST' the requested value

=item +: used before an option indicates 'AT LEAST' the requested value

=back

=head2 EXAMPLES

=over 

=item find all files named F<*file*> under /mnt/lustre/dir3:

C<lustre_operator /usr/bin/lfs /mnt/lustre3 find /mnt/lustre3/dir3 --name \*file\*>

=back

=cut



#################################################################################
# run - entry point when run as a script
# 
# parses arguments/options and dispatches to subcommand run_* handler
#
# Inputs
#    list of command-line arguments following the find command
# Returns
#    Nothing (never returns)
#################################################################################
sub run {
    my @args = @_;
    
    #############################################################################
    # Process command-line
    #############################################################################
    if ($args[0] =~ m/(--help|-h)/) {
	# shortcut to full help (and exit)
	exit_full_help();
    }
    my $lfs_bin_taint = shift @args or error_exit_usage("Must specify absolute path to lfs binary as first argument", "GENERAL");
    my $lfs_bin = untaint_valid_abs_path($lfs_bin_taint) or error_exit_usage("Specified lfs binary [$lfs_bin_taint] is not a valid absolute path", "GENERAL");
    (-x $lfs_bin && (-f $lfs_bin || -l $lfs_bin)) or error_exit_usage("Specified lfs binary [$lfs_bin] is not executable", "GENERAL");
    
    my $lustre_filesystem_taint = shift @args or error_exit_usage("Must specify lustre_filesystem as second argument", "GENERAL");
    # verify that lustre_filesystem is listed in /proc/mounts or /etc/mtab (and untaint)
    my $lustre_filesystem = untaint_valid_mount_point($lustre_filesystem_taint) or error_exit("Invalid lustre filesystem [$lustre_filesystem_taint], must specify absolute path to lustre mount point (as listed in /proc/mounts or /etc/mtab)");
    
    my $lfs_cmd = shift @args or error_exit_usage("Must specify getquota, setquota, or find as third argument", "GENERAL");
    $lfs_cmd =~ m/^(getquota|setquota|find|[-]\S+)$/ or error_exit_usage("Unrecognized command: $lfs_cmd");

    #############################################################################
    # Launch subcommand handlers
    #############################################################################
    if ($lfs_cmd eq "getquota") {
	run_getquota($lfs_bin, $lustre_filesystem,  @args);
    } elsif ($lfs_cmd eq "setquota") {
	run_setquota($lfs_bin, $lustre_filesystem, @args);
    } elsif ($lfs_cmd eq "find") {
	run_find($lfs_bin, $lustre_filesystem, @args);
    } else {
	# did not specify command, check for generic options
	unshift @args, $lfs_cmd;
	my $help = 0;
	GetOptionsFromArray( \@args,
			     'help|h|?' => \$help ) or error_exit_usage("could not process generic options");
	if ($help) {
	    exit_full_help();
	}
    }
}


#################################################################################
# run_getquota - handle the getquota subcommand
# 
# parses arguments/options and handles the getquota subcommand 
#
# Inputs
#    1: lfs binary
#    2: lustre mount point
#    remaining: list of command-line arguments following the find command
# Returns
#    Nothing (never returns)
#################################################################################
sub run_getquota {
    my $lfs_bin = shift;
    my $filesystem = shift;
    my @args = @_;

    # getquota: Display disk usage and limits.
    my @users;
    my @groups;
    
    # columns to include in output 
    my @columns;
    
    # units
    my $size_units="";
    my $inode_units="";
    my $time_units="";
    
    # output format: json, csv, tsv, or spacesv (default: tsv)
    my $format = "tsv"; 

    # get options
    GetOptionsFromArray( \@args,
			 "user|u=s" => \@users,
			 "group|g=s" => \@groups,
			 "column|c=s" => \@columns,
			 "format|f=s" => \$format,
			 "size-units|s=s" => \$size_units,
			 "inode-units|i=s" => \$inode_units,
			 "time-units|t=s" => \$time_units,
			 "human|h" => sub {
			     if (!$size_units) {
				 $size_units = "human_binary";
			     }
			     if (!$inode_units) {
				 $inode_units = "human";
			     }
			     if (!$time_units) {
				 $time_units = "human";
			     }
			 },
			 "human_decimal|d" => sub {
			     if (!$size_units) {
				 $size_units = "human_decimal";
			     }
			     if (!$inode_units) {
				 $inode_units = "human";
			     }
			     if (!$time_units) {
				 $time_units = "human";
			     }
			 },
			 "help|?" => sub { exit_usage("Help for getquota command:","GETQUOTA") },
	) or error_exit_usage("Could not parse getquota options", "GETQUOTA");
    
    if (@users <= 0 && @groups <= 0) {
	error_exit_usage("Nothing to do for getquota: please specify user(s) and/or group(s)", "GETQUOTA");
    }
    
    ($format =~ m/^(json|csv|tsv|spacesv|dumper)$/) or error_exit_usage("Unsupported format $format", "GETQUOTA");

    # get quotas into hash
    my %quotas;
    foreach my $user (@users) {
	$quotas{user}{$user} = lfs_get_quota($lfs_bin, $filesystem, "user", $user);
    }
    foreach my $group (@groups) {
	$quotas{group}{$group} = lfs_get_quota($lfs_bin, $filesystem, "group", $group);
    }
    
    # print quotas
    output_quotas(\%quotas, $format, $size_units, $inode_units, $time_units, \@columns);
}


#################################################################################
# run_setquota - setquota subcommand handler
# 
# parses arguments/options and handles the setquota subcommand 
#
# Inputs
#    1: lfs binary
#    2: lustre mount point
#    remaining: list of command-line arguments following the find command
# Returns
#    Nothing (never returns)
#################################################################################
sub run_setquota {
    my $lfs_bin = shift;
    my $filesystem = shift;
    my @args = @_;

    # options
    my @users;
    my @groups;
    my $size_softlimit = 0;
    my $force_size_softlimit = 0;
    my $size_hardlimit = 0;
    my $force_size_hardlimit = 0;
    my $inode_softlimit = 0;
    my $force_inode_softlimit = 0;
    my $inode_hardlimit = 0;
    my $force_inode_hardlimit = 0;
    
    # get options
    GetOptionsFromArray( \@args,
			 "user|u=s" => \@users,
			 "group|g=s" => \@groups,
			 "size-softlimit|b=s" => \$size_softlimit,
			 "force-size-softlimit" => \$force_size_softlimit,
			 "size-hardlimit|B=s" => \$size_hardlimit,
			 "force-size-hardlimit" => \$force_size_hardlimit,
			 "inode-softlimit|i=s" => \$inode_softlimit,	
			 "force-inode-softlimit" => \$force_inode_softlimit,	
			 "inode-hardlimit|I=s" => \$inode_hardlimit,
			 "force-inode-hardlimit" => \$force_inode_hardlimit,
			 "help|?" => sub { exit_usage("Help for setquota command:","SETQUOTA") },
	) or error_exit_usage("Could not parse setquota options", "SETQUOTA");
    
    if (@users <= 0 && @groups <= 0) {
	error_exit_usage("Nothing to do for setquota: please specify user(s) and/or group(s)", "SETQUOTA");
    }

    my %newquota;
    my %checkquota;
    if ($size_softlimit) {
	$newquota{"size-softlimit"} = $size_softlimit;
	if ( !$force_size_softlimit ) {
	    $checkquota{"size-softlimit"} = $size_softlimit;
	}
    }
    if ($size_softlimit) {
	$newquota{"size-hardlimit"} = $size_hardlimit;
	if ( !$force_size_hardlimit ) {
	    $checkquota{"size-hardlimit"} = $size_hardlimit;
	}
    }
    if ($inode_softlimit) {
	$newquota{"inode-softlimit"} = $inode_softlimit;
	if ( !$force_inode_softlimit ) {
	    $checkquota{"inode-softlimit"} = $inode_softlimit;
	}
    }
    if ($inode_softlimit) {
	$newquota{"inode-hardlimit"} = $inode_hardlimit;
	if ( !$force_inode_hardlimit ) {
	    $checkquota{"inode-hardlimit"} = $inode_hardlimit;
	}
    }
    
    if ( keys %newquota < 1) {
	error_exit("no limits specified, nothing to do.");
    }

    if ( keys %checkquota > 0 ) {
	# check the existing quota for each user and group against the new proposed quota
	# refuse to set quota over the existing usage without a --force-* option
	my @existing_quotas;
	foreach my $user (@users) {
	    push @existing_quotas, lfs_get_quota($lfs_bin, $filesystem, "user", $user);
	}
	foreach my $group (@groups) {
	    push @existing_quotas, lfs_get_quota($lfs_bin, $filesystem, "group", $group);
	}
	
	# check proposed quotas against existing usage (error_exit if change would put any user/group over)
	check_quota_change(\@existing_quotas, \%checkquota);
    }
    
    # set quota for each user and group
    foreach my $user (@users) {
	lfs_set_quota($lfs_bin, $filesystem, "user", $user, \%newquota);
    }
    foreach my $group (@groups) {
	lfs_set_quota($lfs_bin, $filesystem, "group", $group, \%newquota);
    }
}


#################################################################################
# run_find - find subcommand handler
# 
# parses arguments/options and handles the find subcommand 
#
# Inputs
#    1: lfs binary
#    2: lustre mount point
#    remaining: list of command-line arguments following the find command
# Returns
#    Nothing (never returns)
#################################################################################
sub run_find {
    my $lfs_bin = shift;
    my $filesystem = shift;
    my @args = @_;

    my @lfs_args;
    push @lfs_args, "find";
    my $matchpat = 0;

    # stat the mount point to get the dev_t for the filesystem (to check each <dir|file> entry against)
    (my $fs_dev, undef) = stat $filesystem or error_exit("could not stat mount point $filesystem");
    
    # the first arguments (until the first ! or -) must start with $filesystem
    while (!$matchpat) {
	my $dirorfile = shift @args;
	if (!defined($dirorfile) || $dirorfile =~ m/^[-!]/) {
	    # have an argument staring with '!' or '-' (or no argument)
	    $matchpat = 1;
	    unshift @args, $dirorfile;
	} else {
            $dirorfile =~ m/^($filesystem.*)$/ or error_exit("<dir|file> $dirorfile must begin with $filesystem");
	    $dirorfile = $1;
	    # -f and -d will follow symlinks (as does `lfs find`)
	    ( -f $dirorfile || -d $dirorfile ) or error_exit("$dirorfile is not a plain file or directory");
	    # stat also follows symlinks, so in case of symlinks it is the target stats that we will get
	    (my $dirorfile_dev, undef) = stat $dirorfile or error_exit("could not stat <dir|file> $dirorfile");
	    ($dirorfile_dev == $fs_dev) or error_exit("$dirorfile and $filesystem are not on the same device ($dirorfile is on device $dirorfile_dev but $filesystem is on device $fs_dev)");
	    push @lfs_args, $dirorfile;
	}
    } 
    (@lfs_args > 0) or error_exit("must specify <dir|file> before match paramters");
    # now we should be in match parameters section 
    my $arg = shift @args;
    while (defined($arg)) {
	if ($arg =~ m/^[!]$/) {
	    push @lfs_args, '!';
	} elsif ($arg =~ m/^(--{0,1}[a-zA-Z]{1,})$/) {
	    $arg = $1;
	    if ($arg =~ m/^(--print0{0,1}|-[pP])$/) {
		# have one of the args that does not require a parameter
		push @lfs_args, $arg;
	    } else {
		# option requires a parameter
		my $param = shift @args;
		# check param syntax depending on value of arg
		if ($arg =~ m/^-(-(atime|mtime|ctime)|[AMC])$/) {
		    # [+-]N
		    $param =~ m/^([-+]{0,1}[0-9]+)$/ or error_exit("parameter after $arg was not [+-]N ($param)");
		    $param = $1;
		} elsif ($arg =~ m/^-(-(maxdepth)|[D])$/) {
		    # N
		    $param =~ m/^([0-9]+)$/ or error_exit("parameter after $arg was not numeric ($param)");
		    $param = $1;
		} elsif ($arg =~ m/^-(-(size)|[s])$/) {
		    # [+-]N[bkMGTP]
		    $param =~ m/^([-+]{0,1}[0-9]+[bkMGTP]{0,1})$/ or error_exit("parameter after $arg was not [+-]N[bkMGTP] ($param)");
		    $param = $1;
		} elsif ($arg =~ m/^-(-(name)|[n])$/) {
		    # <pattern>
		    $param =~ m/^([^\/]+)$/ or error_exit("parameter after $arg contained a '/' ($param)");
		    $param = $1;
		} elsif ($arg =~ m/^-(-(obd)|[O])$/) {
		    # <uuid[s]>
		    $param =~ m/^([-_,[:alnum:]]+)$/ or error_exit("parameter after $arg was not <uuid[s]> ($param)");
		    $param = $1;
		} elsif ($arg =~ m/^-(-(type)|[t])$/) {
		    # <filetype> == [bcdpflsD]
		    $param =~ m/^([bcdpflsD])$/ or error_exit("parameter after $arg was not [bcdpflsD] ($param)");
		    $param = $1;
		} elsif ($arg =~ m/^-(-(uid|user|gid|group)|[uUgG])$/) {
		    # <gid>|<gname>|<uid>|<uname>
		    $param =~ m/^([0-9]+|[a-z_][a-z0-9_-]{0,15})$/ or error_exit("parameter after $arg was not <gid>|<gname>|<uid>|<uname> ($param)");
		    $param = $1;
		} else {
		    error_exit("unsupported find argument $arg");
		}
		push @lfs_args, $arg;
		push @lfs_args, $param;
	    }
	} else {
	    error_exit("invalid find argument $arg");
	}
	$arg = shift @args;
    }
    # exec to run lfs find (never to return)
    exec_lfs($lfs_bin, @lfs_args);
    error_exit("unexpected error in exec_lfs find");
}

#################################################################################
# untaint_valid_mount_point - return untainted mount point if it is valid
# 
# verifies the given mount point is specified as an absolute path, then 
# checks if mount point is valid by looking it up in /proc/mounts or /etc/mtab
#
# Inputs
#    1: mount point
# Returns
#    untainted mount point or undef if not valid
#################################################################################
sub untaint_valid_mount_point {
    my $mount_point = shift;
    my $validated_filesystem = undef;

    if ( valid_abs_path($mount_point) ) {
	# have valid path based on regex, check for it in /proc/mounts or /etc/mtab
	my $mfile = "/proc/mounts";
	if (! open MOUNTS, "<$mfile" ) {
	    $mfile = "/etc/mtab";
	    open MOUNTS, "<$mfile" or error_exit("could not open /proc/mounts or /etc/mtab for reading");
	}
	MOUNTLINE: while( my $mountline = <MOUNTS> ) {
	    chomp $mountline;
	    my ($spec, $mountpoint, $type, undef) = split /\s+/, $mountline, 4;
	    if ($mountpoint eq $mount_point) {
		if ($type eq "lustre") {
		    # validated, untaint
		    $mountpoint =~ m/^(\/.*)$/ or error_exit("did not have absolute path as mount point: $mountpoint");
		    $validated_filesystem = $1;
		    last MOUNTLINE;
		} else {
		    error_exit("$mount_point was listed in $mfile but was not of type lustre");
		}
	    }
	}
	close MOUNTS;
    }
    return $validated_filesystem;
}

#################################################################################
# untaint_valid_abs_path - return untainted absolute path if it appears valid
# 
# Inputs
#    1: absolute path
# Returns
#    untainted absolute path or undef if not valid
#################################################################################
sub untaint_valid_abs_path {
    my $filepath = shift;
    if (valid_abs_path($filepath)) {
	$filepath =~ m/^(\/.*)$/;
	$filepath = $1;
	return $filepath;
    } else {
	return undef;
    }
}

#################################################################################
# valid_abs_path - check if a path is absolute and plausibly valid
# 
# Inputs
#    1: absolute path
# Returns
#    1 if valid, undef if not
#################################################################################
sub valid_abs_path {
    my $filepath = shift;
    ($filepath =~ /^\//) and valid_path($filepath) ? 1 : undef;
}

#################################################################################
# valid_path - check if a path is plausibly valid (contains no illegal characters)
# 
# Inputs
#    1: path
# Returns
#    1 if valid, undef if not
#################################################################################
sub valid_path {
    my $filepath = shift;
    $filepath !~ /$ILLEGAL_PATH_REGEX/ ? 1 : undef;
}

#################################################################################
# over_quota - check if usage is over quota (handling unlimited quotas)
# 
# Inputs
#    1: quota value
#    2: used value
# Returns
#    1 if over quota, undef if not
#################################################################################
sub over_quota {
    my $quota = shift || $NO_QUOTA;
    my $used = shift or error_exit("over_quota called without used value");

    $quota =~ m/^($NO_QUOTA|[0-9]+)$/ or error_exit("quota [$quota] was neither $NO_QUOTA nor an integer");

    if (($quota eq $NO_QUOTA) ||
	($quota >= $used)) {
	# not over quota
	return undef;
    } 
    
    # over quota
    return 1;
}

#################################################################################
# error_exit - print message to STDERR and exit with error
# 
# Inputs
#    1: message to print to STDERR
# Returns
#    Nothing (never returns)
#################################################################################
sub error_exit {
    my $message = shift;
    die "Error: $message\n";
}

#################################################################################
# error_exit_usage - print message and usage to STDERR,  and exit with error (1)
# 
# Inputs
#    1: message to print to STDERR
#    2: command whose usage should be printed
# Returns
#    Nothing (never returns)
#################################################################################
sub error_exit_usage {
    my $message = shift;
    my $command = shift || "";
    
    my $sections = [ qw(SYNOPSIS ARGUMENTS OPTIONS) ];
    if ($command ne "") {
	$sections = [ "$command/SYNOPSIS", "$command/ARGUMENTS", "$command/OPTIONS" ];
    }
    
    pod2usage({
	-noperldoc => 1,
	-message => "Error: $message\n",
	-exitval => 1,
	-output => ">&STDERR",
	-verbose => 99,
	-sections => $sections,
	      });

    # this should not be reached, but call it in case something goes wrong with pod2usage
    error_exit($message);
}

#################################################################################
# exit_usage - print message to STDOUT, print usage, and exit successfully
# 
# Inputs
#    1: message to print to STDOUT
#    2: command whose usage should be printed
# Returns
#    Nothing (never returns)
#################################################################################
sub exit_usage {
    my $message = shift;
    my $command = shift || "";
    
    my $sections = [ qw(SYNOPSIS ARGUMENTS OPTIONS) ];
    if ($command ne "") {
	$sections = [ "$command/SYNOPSIS", "$command/ARGUMENTS", "$command/OPTIONS" ];
    }
    
    pod2usage({
	-noperldoc => 1,
	-message => "$message\n",
	-exitval => 0,
	-output => ">&STDOUT",
	-verbose => 99,
	-sections => $sections,
	      });

    # this should not be reached, but call it in case something goes wrong with pod2usage
    error_exit($message);
}

#################################################################################
# exit_full_help - print full perldocs to STDOUT and exit successfully
# 
# Inputs
#    None
# Returns
#    Nothing (never returns)
#################################################################################
sub exit_full_help {
    pod2usage({
	-noperldoc => 1,
	-verbose => 2,
	-message => "Displaying full help:\n",
	-exitval => 0,
	-output => ">&STDOUT",
	      });
    
    # this should not be reached, but call it in case something goes wrong with pod2usage
    error_exit("exit_full_help reached end unexpectedly");
}

#################################################################################
# exec_lfs - call the lfs binary 
# 
# all calls to external lfs binary should go through this subroutine.
# it completely drops the environment before exec'ing and uses the multiple-
# argument form of exec so that the shell will not be invoked.
# this routine never returns (execution passes to the external process or it 
# exits with an error)
# 
# Inputs
#    1: path to lfs binary
#    2: array of lfs command line args
# Returns
#    Nothing (never returns)
#################################################################################
sub exec_lfs {
    my $lfs_bin = shift;
    my @lfs_args = @_;

    # completely squash environment before exec
    %ENV = ();

    # call exec and never return (unless command is not found)
    exec { $lfs_bin } $lfs_bin, @lfs_args or error_exit("couldn't exec $lfs_bin");
    
    error_exit("unexpectedly reached end of exec_lfs");
}


#################################################################################
# exec_lfs_pipe_open - return results from calling lfs binary
# 
# fork a child process and calls exec_lfs, returning a filehandle to read STDOUT 
# from the command.
# 
# Inputs
#    1: path to lfs binary
#    2: array of lfs command line args
# Returns
#    Filehandle to read from STDOUT of the lfs command
#################################################################################
sub exec_lfs_pipe_open {
    my $lfs_bin = shift;
    my @lfs_args = @_;
    
    # this code adapted from "safe pipe open for reading" 
    # described in: http://perldoc.perl.org/perlipc.html#Safe-Pipe-Opens
    my $child_stdout_fh;
    my $pid = open($child_stdout_fh, "-|");
    defined($pid) or error_exit("can't fork: $!");
    
    if (!$pid) { # $pid is only set in parent
	# child, call exec and never return (exec_lfs will exit on error)
	exec_lfs($lfs_bin, @lfs_args);
	
	# as a safety precaution, force child to exit (this should never be reached)
	error_exit("child process attempted to continue after exec_lfs");
    } else { 
        # parent, process data from child
	return $child_stdout_fh;
    }

    # this point should not be reached
    error_exit("unexpected error in exec_lfs_pipe_open");
}


#################################################################################
# lfs_get_quota - gets all quota data for a user or group and returns it
# 
# Fills a quota hash with keys for each of the quota limits:
# "size-hardlimit" (Bytes), "inode-hardlimit" (inode count)
# "size-softlimit" (Bytes), "inode-softlimit" (inode count)
# 
# As well as how much is currently in use and remaining:
# "size-used" (Bytes), "inode-used" (inode count)
# "size-remaining" (Bytes), "inode-remaining" (inode count)
# "size-overquota", "inode-overquota" (both "*" if over, "" if not)
# 
# And the grace period remaining since soft quota has been exceeded:
# "size-grace", "inode-grace" (both in seconds)
# 
# And finally some metadata regarding to what the quota pertains: 
# "filesystem" (lustre filesystem)
# "type" ("user"|"group")
# "name" (<user_name>|<group_name>)
# "timestamp" (timestamp in ISO8601 format)
# 
# Inputs
#    1: path to lfs binary
#    2: lustre filesystem
#    3: "user"|"group"
#    4: <user_name>|<group_name>
# Returns
#    Hashref to quota with units in Bytes (not kB), inodes, and seconds
#################################################################################
sub lfs_get_quota {
    my $lfs_bin = shift;    # 1: path to lfs binary
    my $filesystem = shift; # 2: lustre filesystem mount point
    my $quota_type = shift; # 3: "user" or "group"
    my $quota_name = shift; # 4: user or group name

    # validate arguments and untaint
    valid_abs_path($filesystem) or error_exit("get_quota: filesystem $filesystem not valid");
    $filesystem =~ m/^(\/.*)$/;
    $filesystem = $1;
    $quota_name =~ m/^([0-9]+|[a-z_][a-z0-9_-]{0,31})$/ or error_exit("user/group name $quota_name not valid");
    $quota_name = $1;
    
    my $lfs_quota_out_fh;
    if ($quota_type eq "user") {
	$lfs_quota_out_fh = exec_lfs_pipe_open($lfs_bin, "quota", "-u", $quota_name, $filesystem);
    } elsif ($quota_type eq "group") {
	$lfs_quota_out_fh = exec_lfs_pipe_open($lfs_bin, "quota", "-g", $quota_name, $filesystem);
    } else {
	error_exit("unexpected value for quota type: $quota_type");
    
    }

    my %quota;
    $quota{"filesystem"} = $filesystem;
    $quota{"type"} = $quota_type;
    $quota{"name"} = $quota_name;
    
    my $usergroupline = <$lfs_quota_out_fh>;
    defined($usergroupline) or error_exit("no output from lfs quota for $filesystem $quota_type $quota_name");
    chomp $usergroupline;
    my $usergroupname = "";
    my $ugid = -1;
    if ($quota_type eq 'user') {
	$usergroupline =~ m/user\s(\S+)/ or error_exit("could not find user in lfs quota output for $filesystem $quota_type $quota_name");
	$usergroupname = $1;
	$usergroupline =~ m/uid\s([0-9]+)/ or error_exit("could not find uid in lfs quota output for $filesystem $quota_type $quota_name");
	$ugid = $1;
    } elsif ($quota_type eq 'group') {
	$usergroupline =~ m/group\s(\S+)/ or error_exit("could not find group in lfs quota output for $filesystem $quota_type $quota_name");
	$usergroupname = $1;
	$usergroupline =~ m/gid\s([0-9]+)/ or error_exit("could not find gid in lfs quota output for $filesystem $quota_type $quota_name");
	$ugid = $1;
    } else {
	error_exit("invalid quota_type $quota_type in lfs_get_quota for $filesystem $quota_type $quota_name");
    }
    
    my $headerline = <$lfs_quota_out_fh>;
    chomp $headerline;
    $headerline =~ m/kbytes\s+quota\s+limit\s+grace\s+files\s+quota\s+limit\s+grace\s*$/ or error_exit("unexpected header in output from lfs quota for $filesystem $quota_type $quota_name");
    
    my $fsline = <$lfs_quota_out_fh>;
    chomp $fsline;
    $fsline =~ m/^\s*$filesystem\s*$/ or error_exit("unexpected filesystem reported from lfs quota: $fsline (expecting: $filesystem)");
    
    my $quotaline = <$lfs_quota_out_fh>;
    chomp $quotaline;
    $quotaline =~ m/([0-9-]+)([*]?) # $1, $2 - size used in blocks followed by '*' if over quota
                        \s+             
                        ([0-9-]+|$LFS_QUOTA_SIZE_UNLIMITED)       # $3 - size soft limit in blocks
                        \s+
                        ([0-9-]+)       # $4 - size hard limit in blocks
                        \s+
                        (\S+|$LFS_GRACE_INACTIVE)           # $5 - block grace time remaining
                        \s+
                        ([0-9-]+)([*]?) # $6, $7 - inodes used followed by '*' if over quota
                        \s+
                        ([0-9-]+)       # $8 - inode soft limit
                        \s+
                        ([0-9-]+)       # $9 - inode hard limit
                        \s+
                        (\S+|$LFS_GRACE_INACTIVE)           # $10 - inode grace time remaining
                        \s*
                        $/x or error_exit("unexpected data in output from lfs quota for $filesystem $quota_type $quota_name: [$quotaline]");
    # post-process into standard units (bytes, inodes, seconds)
    $quota{"size-used"} = lfs_blocks_used_to_bytes($1);
    $quota{"size-overquota"} = $2;
    $quota{"size-softlimit"} = lfs_block_limit_to_bytes($3);
    $quota{"size-hardlimit"} = lfs_block_limit_to_bytes($4);
    $quota{"size-grace"} = lfs_grace_time_to_seconds($5);
    $quota{"inode-used"} = $6; 
    $quota{"inode-overquota"} = $7;
    $quota{"inode-softlimit"} = lfs_process_inode_limit($8);
    $quota{"inode-hardlimit"} = lfs_process_inode_limit($9);
    $quota{"inode-grace"} = lfs_grace_time_to_seconds($10);
    
    # record timestamp along with the data
    $quota{"timestamp"} = DateTime->now()->iso8601();
    
    # calculate remaining if there is a quota set
    my @size_quotas = grep(!/^$NO_QUOTA$/, $quota{"size-softlimit"}, $quota{"size-hardlimit"});
    $quota{"size-remaining"} = (@size_quotas > 0) ? (min(@size_quotas) - $quota{"size-used"}) : $NO_QUOTA;
    my @inode_quotas = grep(!/^$NO_QUOTA$/, $quota{"inode-softlimit"}, $quota{"inode-hardlimit"});
    $quota{"inode-remaining"} = (@inode_quotas > 0) ? (min(@inode_quotas) - $quota{"inode-used"}) : $NO_QUOTA;
    
    # shouldn't be any more output - if there is, signal an error
    while(my $emptyline = <$lfs_quota_out_fh>) {
	chomp $emptyline;
	$emptyline =~ m/^\s*$/ or error_exit("unexpected additional output from lfs quota for $filesystem $quota_type $quota_name: $emptyline");
    }
    
    close($lfs_quota_out_fh) or error_exit("lfs quota failed for $filesystem $quota_type $quota_name: $!");
    
    return \%quota;
}


#################################################################################
# lfs_set_quota - sets quota for a user or group and returns on success
# Inputs
#    1: path to lfs binary
#    2: lustre filesystem
#    3: "user"|"group"
#    4: <user_name>|<group_name>
#    5: hashref to quota hash containing at least one of:
#       "size-hardlimit", "size-softlimit", "inode-hardlimit", "inode-softlimit"
# Returns
#    1 on success, undef on failure
#################################################################################
sub lfs_set_quota {
    my $lfs_bin = shift;    # 1: path to lfs binary
    my $filesystem = shift; # 2: lustre filesysteam
    my $quota_type = shift; # 3: "user" or "group"
    my $quota_name = shift; # 4: user or group name
    my $new_quota = shift;  # 5: hashref for quota to set

    my @lfs_args;
    push @lfs_args, "setquota";
    
    my $uorg;
    if ($quota_type eq 'user') {
	$uorg = "-u";
    } elsif ($quota_type eq 'group') {
	$uorg = "-g";
    } else {
	error_exit("invalid quota_type $quota_type in lfs_set_quota for $filesystem $quota_type $quota_name");
    }
    push @lfs_args, $uorg, $quota_name;

    if (defined($new_quota->{"size-softlimit"})) { 
	push @lfs_args, "--size-softlimit", $new_quota->{"size-softlimit"};
    }
    if (defined($new_quota->{"size-hardlimit"})) {
	push @lfs_args, "--size-hardlimit", $new_quota->{"size-hardlimit"};
    }
    if (defined($new_quota->{"inode-softlimit"})) {
	push @lfs_args, "--inode-softlimit", $new_quota->{"inode-softlimit"};
    }
    if (defined($new_quota->{"inode-hardlimit"})) {
	push @lfs_args, "--inode-hardlimit", $new_quota->{"inode-hardlimit"};
    }
    push @lfs_args, $filesystem;
    my $lfs_setquota_out_fh = exec_lfs_pipe_open($lfs_bin, @lfs_args);
    
    close($lfs_setquota_out_fh) or error_exit("lfs setquota failed for $filesystem $quota_type $quota_name");
    return (($?>>8) ? undef : 1);
}

#################################################################################
# lfs_process_inode_limit - process inode limits reported by lfs command
# 
# Inputs
#    1: inode count as output by lfs command
# Returns
#    inode count or $NO_QUOTA if unlimited
#################################################################################
sub lfs_process_inode_limit {
    my $inode_count = shift;
    
    if ($inode_count =~ m/^$LFS_QUOTA_INODE_UNLIMITED$/) {
        return $NO_QUOTA;
    } else {
	return $inode_count;
    }
}

#################################################################################
# lfs_block_limit_to_bytes - convert block limit reported by lfs command to bytes
# 
# Inputs
#    1: block limit as output by lfs command
# Returns
#    limit in bytes or $NO_QUOTA if unlimited
#################################################################################
sub lfs_block_limit_to_bytes {
    my $blocks = shift;
    my $bytes = 0;

    if ($blocks =~ m/^$LFS_QUOTA_SIZE_UNLIMITED$/) {
	$bytes = $NO_QUOTA;
    } else {
	$bytes = $blocks * $LFS_BLOCKSIZE;
    }
    
    return $bytes;
}

#################################################################################
# lfs_blocks_used_to_bytes - convert blocks used reported by lfs command to bytes
# 
# Inputs
#    1: blocks used as output by lfs command
# Returns
#    bytes used or $NO_QUOTA if unlimited
#################################################################################
sub lfs_blocks_used_to_bytes {
    my $blocks = shift;
    
    return ($blocks * $LFS_BLOCKSIZE);
}

#################################################################################
# lfs_grace_time_to_seconds - convert grace time reported by lfs command to sec.
# 
# Inputs
#    1: grace time as output by lfs command
# Returns
#    grace time in seconds or $NO_QUOTA if unlimited
#################################################################################
sub lfs_grace_time_to_seconds {
    my $gracetime = shift;
    my $seconds = 0;
    
    # gracetime can be in seconds already or can be something like: "6d23h59m50s"
    if ($gracetime =~ m/^$LFS_GRACE_INACTIVE$/) {
	$seconds = $TIMER_INACTIVE;
    } elsif ($gracetime =~ m/[dhms]/) {
	# process in d h m s format
	$gracetime =~ m/^([0-9]*)d?([0-9]*)h?([0-9]*)m?([0-9]*)s?/ or error_exit("lfs_process_grace_to_seconds: could not process gracetime: $gracetime");
    } elsif ($gracetime =~ m/^[0-9]+$/) {
	# process as s
	$seconds = $gracetime;
    }
    return $seconds;
}

#################################################################################
# check_quota_change - checks whether new quota would put old quota(s) over quota 
# that were not previously over quota
# 
# Inputs
#    1: ref to array of hashes of old quotas
#    2: ref to hash of new quota limits to check
# Returns
#    1 on success, exits process on failure
#################################################################################
sub check_quota_change {
    my $old_quotas = shift;
    my $new_quota = shift;
    
    foreach my $old_quota (@{$old_quotas}) {
	foreach my $limit_key (keys %{$new_quota}) {
	    $limit_key =~ m/^(size|inode)-(softlimit|hardlimit)$/ or error_exit("check_quota_change unrecognised limit $limit_key");
	    my $used_key = $1."-used";
	    if ( !over_quota($old_quota->{$limit_key}, $old_quota->{$used_key}) &&
		 over_quota($new_quota->{$limit_key}, $old_quota->{$used_key})) {
		error_exit($old_quota->{"type"}." ".$old_quota->{"name"}." is not currently over ".$limit_key." quota but new quota would put it over quota: refusing without --force-".$limit_key);
	    }
	}
    }
    return 1;
}

#################################################################################
# output_quotas - print quotas (or subset of quota) in specified format and units
# 
# Inputs
#    1: ref to array of hashes of quotas to print
#    2: format ("json", "csv", "tsv", "spacesv", "dumper")
#    3: size units
#    4: inode units
#    5: time units
#    6: ref to array of columns to include (if not specified, include all)
# Returns
#    1 on success, exits process on failure
#################################################################################
sub output_quotas {
    my $quotas = shift;
    my $format = shift || "tsv";
    my $size_units = shift; 
    my $inode_units = shift; 
    my $time_units = shift; 
    my $columns = shift;

    my $unitquotas;
    foreach my $type (keys %{$quotas}) {
	foreach my $name (keys %{$quotas->{$type}}) {
	    my $quota = $quotas->{$type}->{$name};
	    error_exit("output_quotas: type did not match for $type/$name") unless $quota->{"type"} eq $type;
	    error_exit("output_quotas: name did not match for $type/$name") unless $quota->{"name"} eq $name;
	    foreach my $key (keys %{$quota}) {
		if ($key =~ m/^size-(used|softlimit|hardlimit|remaining)$/ && $quota->{$key} =~ m/^[0-9]+$/) {
		    $unitquotas->{$type}{$name}{$key} = convert_bytes($quota->{$key}, $size_units);
		} elsif ($key =~ m/^inode-(used|softlimit|hardlimit|remaining)$/ && $quota->{$key} =~ m/^[0-9]+$/) {
		    $unitquotas->{$type}{$name}{$key} = convert_inodes($quota->{$key}, $inode_units);
		} elsif ($key =~ m/-grace$/ && $quota->{$key} =~ m/^[0-9]+$/) {
		    $unitquotas->{$type}{$name}{$key} = convert_seconds($quota->{$key}, $time_units);
		} else {
		    $unitquotas->{$type}{$name}{$key} = $quota->{$key};
		}
	    }
	}
    }
    
    if (lc($format) =~ m/^(json|dumper)$/) {
	my $subset_quotas;
	if (@{$columns} > 0) {
	    foreach my $col (@{$columns}) {
		foreach my $type (keys %{$unitquotas}) {
		    foreach my $name (keys %{$unitquotas->{$type}}) {
			$subset_quotas->{$type}{$name}{$col} = $unitquotas->{$type}{$name}{$col};
		    }
		}
	    }
	} else {
	    # include all columns in json output
	    $subset_quotas = $unitquotas;
	}
	if (lc($format) eq 'json') {
	    output_quotas_json($subset_quotas);
	} elsif (lc($format) eq 'dumper') {
	    output_quotas_dumper($subset_quotas);
	} else {
	    error_exit("output_quotas: unexpected value for format: [$format]");
	}
    } elsif (lc($format) =~ m/^(tsv|csv|spacesv)/) {
	my $field_sep = "\t";
	if ($format eq "csv") {
	    $field_sep = ",";
	} elsif ($format eq "spacesv") {
	    $field_sep = " ";
	}
	my $tablefmt = $1;
	if (@{$columns} > 0) {
	    output_quotas_table($unitquotas, $columns, $field_sep, "\n");
	} else {
	    output_quotas_table($unitquotas, $COLUMN_ORDER, $field_sep, "\n");
	}
    } else {
	error_exit("output_quotas: unsupported output format $format");
    }
    return 1;
}

#################################################################################
# output_quotas_json - print quotas array as JSON
# 
# Inputs
#    1: ref to hash (on <type>) of hashes (on <name>) of hashes of quotas to print
# Returns
#    1 on success, exits process on failure
#################################################################################
sub output_quotas_json {
    my $quotas = shift;
    print JSON::XS->new->pretty(1)->encode($quotas)."\n" or error_exit("output_quotas_json could not encode JSON: $!");
    return 1;
}

#################################################################################
# output_quotas_dumper - print quotas array as Data::Dumper serialised object
# 
# Inputs
#    1: ref to hash (on <type>) of hashes (on <name>) of hashes of quotas to print
# Returns
#    1 on success, exits process on failure
#################################################################################
sub output_quotas_dumper {
    my $quotas = shift;
    my $dumper = Data::Dumper->new([]);
    $dumper->Terse(1);
    $dumper->Values([$quotas]);
    print $dumper->Dump()."\n" or error_exit("output_quotas_dumper could not output quotas: $!");
    return 1;
}

#################################################################################
# output_quotas_table - print quotas array as table with given field and row seps
# 
# Inputs
#    1: ref to array of hashes of quotas to print
#    2: ref to array of columns to print 
#    3: field separator (optional: default "\t")
#    4: row separator (optional: default "\n")
# Returns
#    1 on success, exits process on failure
#################################################################################
sub output_quotas_table {
    my $quotas = shift;
    my $columns = shift;
    my $field_sep = shift || "\t";
    my $row_sep = shift || "\n";

    print join($field_sep, @{$columns}).$row_sep;
    foreach my $type (keys %{$quotas}) {
	foreach my $name (keys %{$quotas->{$type}}) {
	    my $quota = $quotas->{$type}->{$name};
	    error_exit("output_quotas: type did not match for $type/$name") unless $quota->{"type"} eq $type;
	    error_exit("output_quotas: name did not match for $type/$name") unless $quota->{"name"} eq $name;
	    print join($field_sep, map {$quota->{$_}} @{$columns}).$row_sep;
	}
    }
}

#################################################################################
# convert_bytes - convert bytes to formatted units
# 
# Inputs
#    1: bytes
#    2: units
# Returns
#    formatted string including units
#################################################################################
sub convert_bytes {
    my $bytes = shift;
    my $units = shift || "";
    if ( (!$units) || $units eq 'B') {
	return $bytes.$OUTPUT_UNIT_SEP.$units;
    } elsif ($units eq 'human_binary') {
	return convert_bytes_human($bytes, 0);
    } elsif ($units eq 'human_decimal') {
	return convert_bytes_human($bytes, 1);
    } elsif ($units ne 'B') {
	# fixed unit specification requiring conversion
	for (my $i=1; $i<@{$BINARY_UNIT_LABELS}; $i++) {
	    if ($BINARY_UNIT_LABELS->[$i] eq $units) {
		return sprintf("%.1f%s%s", ($bytes / (1024 ** $i)), $OUTPUT_UNIT_SEP, $units);
	    }
	    if ($DECIMAL_UNIT_LABELS->[$i] eq $units) {
		return sprintf("%.1f%s%s", ($bytes / (1000 ** $i)), $OUTPUT_UNIT_SEP, $units);
	    }
	}
    }
    error_exit("unknown size units [$units]. specify one of: ".join(', ', @{$BINARY_UNIT_LABELS}, @{$DECIMAL_UNIT_LABELS}, 'human_binary', 'human_decimal'));
}

#################################################################################
# convert_inodes - convert inode count to formatted units
# 
# Inputs
#    1: inode count
#    2: units
# Returns
#    formatted string including units
#################################################################################
sub convert_inodes {
    my $inodes = shift;
    my $units = shift;
    if (!$units) {
	return $inodes;
    } else {
	if ($units eq 'human') {
	    return convert_inodes_human($inodes);
	} else {
	    # fixed unit specification
	    for (my $i=1; $i<@{$DECIMAL_PREFIXES}; $i++) {
		if ($DECIMAL_PREFIXES->[$i] eq $units) { 
		    return sprintf("%.1f%s%s", ($inodes / (1024 ** $i)), $OUTPUT_UNIT_SEP, $units);
		}
	    }
	}
	error_exit("unknown inode units [$units]. specify one of: ".join(', ', @{$DECIMAL_PREFIXES}, 'human'));
    } 
} 

#################################################################################
# convert_seconds - convert seconds to formatted units
# 
# Inputs
#    1: seconds
#    2: units
# Returns
#    formatted string including units
#################################################################################
sub convert_seconds {
    my $gracetime = shift;
    my $units = shift;
    if ( (!$units) || $units eq 's') {
	return $gracetime.$OUTPUT_UNIT_SEP.$units;
    } elsif ($units eq 'human') {
	return convert_seconds_human($gracetime);
    } else {
	# fixed unit specification
	for (my $i=1; $i<@{$TIME_UNIT_LABELS}; $i++) {
	    if ($TIME_UNIT_LABELS->[$i] eq $units) {
		return sprintf("%.1f%s%s", ($gracetime / $TIME_UNIT_RATIOS->[$i]), $OUTPUT_UNIT_SEP, $units);
	    }
	}
    }
    error_exit("unknown gracetime units [$units]. specify one of: ".join(', ', @{$TIME_UNIT_LABELS}, 'human'));
} 

#################################################################################
# convert_bytes_human - convert bytes to human-readable units
# 
# Inputs
#    1: bytes
#    2: "1" for decimal units ("kB","MB",etc), "0" for binary units ("KiB","MiB",etc)
# Returns
#    formatted string including units
#################################################################################
sub convert_bytes_human {
    my $bytes = shift;
    my $decimal = shift;
    
    my $base = 1024;
    my @labels = @{$BINARY_UNIT_LABELS};
    if($decimal) {
	$base = 1000;
	@labels = @{$DECIMAL_UNIT_LABELS};
    }
    
    my $unit_index = 0;
    TESTUNIT: while($unit_index < $#labels) { # only need to test n-1 as we'll stay in the final unit
	my $unitmax = ($base ** ($unit_index+1)) * $HUMAN_TRIGGER_RATIO;
	if ($bytes < $unitmax) {
	    # we fit in this one, stop here
	    last TESTUNIT;
	}
	$unit_index++;
    }
    
    return sprintf("%.1f%s%s", $bytes / ($base ** $unit_index), $OUTPUT_UNIT_SEP, $labels[$unit_index]);
}

#################################################################################
# convert_inodes_human - convert inode count to human-readable units
# 
# Inputs
#    1: inode count
# Returns
#    formatted string including units
#################################################################################
sub convert_inodes_human {
    my $count = shift;
    
    my $base = 1000;
    my @labels = @{$DECIMAL_PREFIXES};
    
    my $unit_index = 0;
    TESTUNIT: while($unit_index < $#labels) { # only need to test n-1 as we'll stay in the final unit
	my $unitmax = ($base ** ($unit_index+1)) * $HUMAN_TRIGGER_RATIO;
	if ($count < $unitmax) {
	    # we fit in this one, stop here
	    last TESTUNIT;
	}
	$unit_index++;
    }
    
    return sprintf("%.1f%s%s", $count / ($base ** $unit_index), $OUTPUT_UNIT_SEP, $labels[$unit_index]);
}

#################################################################################
# convert_seconds_human - convert seconds to human-readable units
# 
# Inputs
#    1: time in seconds 
# Returns
#    formatted string including units
#################################################################################
sub convert_seconds_human {
    my $seconds = shift;
    
    my $result = "";
    my $remaining = $seconds;
    # convert to ywdhms format (only including the largest non-zero)
    for (my $i=@{$TIME_UNIT_RATIOS}-1; $i>0; $i--) {
	if ( ($seconds / $TIME_UNIT_RATIOS->[$i]) > 1) {
	    # include the i-th part in output
	    my $part = int($remaining / $TIME_UNIT_RATIOS->[$i]);
	    $result .= $part.$TIME_UNIT_LABELS->[$i];
	    $remaining -= $part * $TIME_UNIT_RATIOS->[$i];
	}
    }
    # add in the remaining seconds (0th unit)
    $result .= $remaining.$TIME_UNIT_LABELS->[0];

    return $result;
}


__END__

=head1 DESCRIPTION

A wrapper script for portions of the I<lfs> command distributed with the
Lustre filesystem (L<http://lustre.org/>). Currently wraps up the functionality
of the quota, setquota, and find commands.

It takes as its first argument the mount point of a Lustre filesystem and
will only allow lfs commands to run against that filesystem. It is intended
with use along with sudo, as the sudoers file can specify that individual
users or groups can run this wrapper script against a limited set of Lustre
filesystems specifically listed.


=head1 CONFIGURATION AND ENVIRONMENT

This script is intended to be called using sudo, so for security reasons it 
does not have any external configuration files or environment variables.

In fact, it does not allow dependencies to be loaded from F<.> or from a 
PERL5LIB directory, and when calling lfs it eliminates all environment 
variables. 

You can configure Lustre operators to be able to run this command as root by 
adding an appropriate line to the F</etc/sudoers> file listing the full path 
to this script followed by the mount point of the Lustre file system for 
which they are allowed to run it.

For example:
C<user1 ALL = (root) NOPASSWD : /usr/local/bin/lustre_operator /usr/bin/lfs /mnt/lustre1, \
                              /usr/local/bin/lustre_operator /usr/bin/lfs /mnt/lustre2>


=head1 DEPENDENCIES

=over 

=item Lustre I<lfs> command 

=item L<Getopt::Long> (from CPAN)

=item L<Pod::Usage> (from CPAN)

=back


=head1 INCOMPATIBILITIES

May not work with older versions of the lfs command (Lustre < 1.8), as
this has not been tested. 


=head1 BUGS AND LIMITATIONS

There are no known bugs in this program. 

Please report problems to L<mailto:hgi@sanger.ac.uk>

Patches/pull requests are welcome. 

Development is hosted on github: L<https://github.com/wtsi-hgi/lustre_operator>


=head1 AUTHOR

Joshua C. Randall (jcrandall@alum.mit.edu)


=head1 LICENCE AND COPYRIGHT

Copyright (c) 2013 Genome Research Ltd.

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along with
this program. If not, see <http://www.gnu.org/licenses/>.

=cut







