#!/usr/bin/perl -T 
#################################################################################
#
# Copyright (c) 2013 Genome Research Ltd.
# 
# Author: Joshua C. Randall <jcrandall@alum.mit.edu>
# 
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <http://www.gnu.org/licenses/>.
# 
#################################################################################

package lustre_operator;

=head1 NAME

lustre_operator - a wrapper script for Lustre's 
lfs command suitable for sudo use.

=head1 GENERAL

=head2 SYNOPSIS

lustre_operator B<lfs_binary> B<lustre_filesystem> B<command> [B<options>]

Supports the C<quota>, C<setquota>, and C<find> lfs commands.

=head2 ARGUMENTS

=over

=item B<lustre_filesystem>

An absolute path to the lustre filesystem mount point, as specified 
in F</proc/mounts> and/or F</etc/mtab> (and reported by I<mount>).

=item B<command>

Command (C<quota>, C<setquota>, or C<find>) to run.

=back

=head2 OPTIONS

=over

=item [--help|-?]

=back

=head1 QUOTA

=head2 SYNOPSIS

lustre_operator B<lfs_binary> B<lustre_filesystem> quota [B<options>]

=head2 OPTIONS

=over

=item [--user|-u <uname>|<uid>]

username or uid for a user whose quota you wish to report 
(you can specify this option multiple times)

=item [--group|-g <gname>|<gid>]

group name or gid for a group whose quota you wish to report 
(you can specify this option multiple times)

=item [--human|-h]

use human readable units for both size and inode count 
(synonym for C<--size-units human_binary --inode-units human --time-units human>)

=item [--human_decimal|-d]

use decimal (kB=1000^1, MB=1000^2, GB=1000^3, ...) rather 
than binary (KiB=1024^1, MiB=1024^2, GiB=1024^3, ...) size units 
for human readable output (synonym for 
C<--size-units human_decimal --inode-units human --time-units human>)

overrides --human

=item [--size-units] <size_units>

use fixed units for size. <size_units> can be: "B"|"kB"|"KiB"|"MB"|"MiB"|"GB"|"GiB"|"TB"|"TiB"|"PB"|"PiB"|"EB"|"EiB"|"ZB"|"ZiB"|"YB"|"YiB"|"human_binary"|"human_decimal"

the default is <size_units>="B"

=item [--inode-units] <inode_units>

use fixed units for inode count. <inode_units> can be: ""|"k"|"M"|"G"|"T"|"P"|"E"|"Z"|"Y"|"human"

the default is <inode_units>=""

=item [--time-units] <time_units>

use fixed units for grace time. <time_units> can be: "s"|"m"|"h"|"d"|"w"|"y"|"human"

the default is <time_units>="s"

=item [--format|-f] <format>

specify output format. <format> can be: "json"|"tsv"|"tsv_custom"

=item [--column|-c] <column_header>

select column to include in custom output (you can specify multiple times and order is preserved)

=back

=head2 EXAMPLES

=over

=item get quota information for the current user and group on /mnt/lustre1:

C<lustre_operator /usr/bin/lfs /mnt/lustre1 quota>

=item get quota information for user1 on /mnt/lustre1:

C<lustre_operator /usr/bin/lfs /mnt/lustre1 quota --user user1>

=item get quota information for group1 on /mnt/lustre1:

C<lustre_operator /usr/bin/lfs /mnt/lustre1 quota --group group1>

=back

=head1 SETQUOTA

=head2 SYNOPSIS

lustre_operator B<lfs_binary> B<lustre_filesystem> setquota 
-u|--user|-g|--group <uname>|<uid>|<gname>|<gid> [options]

=head2 OPTIONS

=over

=item -u|--user|-g|--group <uname>|<uid>|<gname>|<gid>

Specify user or group by either name or number. 

=back

=head2 OPTIONS

=over

=item [--size-softlimit|-b <size-softlimit>] 

=item [--force-size-softlimit]

=item [--size-hardlimit|-B <size-hardlimit>]

=item [--force-size-hardlimit]

=item [--inode-softlimit|-i <inode-softlimit>]

=item [--force-inode-softlimit]

=item [--inode-hardlimit|-I <inode-hardlimit>]

=item [--force-inode-hardlimit]

=back

=head2 EXAMPLES

=over

=item set the quota for user user2 on /mnt/lustre2 to 1 TebiByte 
(1024^4 bytes) and 1 million inodes (files):

C<lustre_operator /usr/bin/lfs /mnt/lustre1 setquota --user user2 
--size-hardlimit 1TiB  --inode-hardlimit 1M>

=item set the quota for group group2 on /mnt/lustre2 to 100 megabytes 
(100 * 1000^2 bytes) and 1500 inodes:

C<lustre_operator /usr/bin/lfs /mnt/lustre2 setquota --group group2 
--size-hardlimit 100MB --inode-hardlimit 1.5k>

=item set the quota for group group2 on /mnt/lustre2 to 1 block and 
1 inode (this is the minimum quota):

C<lustre_operator /usr/bin/lfs /mnt/lustre2 setquota --group group2 
--size-hardlimit 1 --inode-hardlimit 1>

=back

=head1 FIND

=head2 SYNOPSIS

lustre_operator B<lfs_binary> B<lustre_filesystem> find B<dir|file> [options]

=head2 ARGUMENTS

=over

=item B<dir|file>

Path from which to begin the recursive find.

=back

=head2 OPTIONS

=over

=item [[!] --atime|-A [+-]N]

=item [[!] --mtime|-M [+-]N]

=item [[!] --ctime|-C [+-]N]

=item [--maxdepth|-D N]

=item [[!] --name|-n <pattern>]

=item [--print0|-P]

=item [--print|-p]

=item [[!] --obd|-O <uuid[s]>]

=item [[!] --size|-s [+-]N[bkMGTP]]

=item [[!] --type|-t <filetype>]

=item [[!] --gid|-g|--group|-G <gid>|<gname>]

=item [[!] --uid|-u|--user|-U <uid>|<uname>]

=back

=head3 NOTES

=over

=item !: used before an option indicates 'NOT' the requested attribute

=item -: used before an value indicates 'AT MOST' the requested value

=item +: used before an option indicates 'AT LEAST' the requested value

=back

=head2 EXAMPLES

=over 

=item find all files named F<*file*> under /mnt/lustre/dir3:

C<lustre_operator /usr/bin/lfs /mnt/lustre3 find /mnt/lustre3/dir3 --name \*file\*>

=back

=cut


use strict;
use warnings;
use 5.008_008;


#################################################################################
# In taint mode, '.' is removed from @INC and PERL5LIB is ignored so we can 
# safely depend on only getting modules from directories compiled into perl
# (see http://perldoc.perl.org/perlsec.html#Taint-mode-and-@INC)
#################################################################################
use Getopt::Long qw(:config posix_default no_ignore_case);
use Pod::Usage;
use DateTime;
use JSON::XS;

#################################################################################
# Configuration
#################################################################################
# the block size that Lustre uses to set and report quota (in Bytes)
my $LFS_BLOCKSIZE      = 1024; 
# the value lfs reports when quota grace time is not active (e.g. not over soft)
my $LFS_GRACE_INACTIVE = "-";
# the value lfs reports when size quota is unlimited
my $LFS_QUOTA_SIZE_UNLIMITED = 0;
# the value lfs reports when inode count quota is unlimited
my $LFS_QUOTA_INODE_UNLIMITED = 0;
# what value to set for minimal size quota
my $LFS_QUOTA_SIZE_MIN = 1;
# what value to set for minimal inode quota
my $LFS_QUOTA_INODE_MIN = 1;
# what value to use if no quota limit is set 
my $NO_QUOTA	       = "unlimited";
# what value to report if grace periods are not active
my $TIMER_INACTIVE     = "inactive";
# regular expression matching illegal filename/path characters
my $ILLEGAL_PATH_REGEX = qr/[\|\\\012\r\n\t\013\*\"\?\<\:\>]/; 
# binary SI units labels from bytes to yobibytes
my $BINARY_UNIT_LABELS  = ["B","KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"];
# decimal SI unit labels from bytes to yottabytes
my $DECIMAL_UNIT_LABELS = ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
# time unit labels from seconds to years
my $TIME_UNIT_LABELS = ["s", "m",  "h",   "d",    "w",      "y"];
my $TIME_UNIT_RATIOS = [  1,  60, 3600, 86400, 604800, 31536000];
# for unitless inode counts
my $DECIMAL_PREFIXES = ["", "k", "M", "G", "T", "P", "E", "Z", "Y"];
# ratio of the next unit value at which to switch to it 
# (e.g. 0.8 implies we would say "0.8 kB" instead of "800 B" 
# whereas 1.2 would mean we would say "1199 B" but "1.2 kB" instead of "1200 B")
my $HUMAN_TRIGGER_RATIO = 0.8;
# the order of output columns in TSV
my $COLUMN_ORDER = ["filesystem","type","name","size-used","size-softlimit","size-hardlimit","size-grace","inode-used","inode-softlimit","inode-hardlimit","inode-grace","timestamp"];
# separator between value and units in output
my $OUTPUT_UNIT_SEP = "";

#################################################################################
# Process command-line
#################################################################################
my $lfs_bin = shift or error_exit_usage("Must specify absolute path to lfs binary as first argument", "GENERAL");
(-x $lfs_bin && (-f $lfs_bin || -l $lfs_bin)) or error_exit_usage("Specified lfs binary [$lfs_bin] is not executable", "GENERAL");

my $lustre_filesystem = shift or error_exit_usage("Must specify lustre_filesystem as second argument", "GENERAL");
# verify that lustre_filesystem is listed in /proc/mounts or /etc/mtab (and untaint)
$lustre_filesystem = valid_lustre_filesystem($lustre_filesystem) or error_exit("Invalid lustre filesystem [$lustre_filesystem], must specify absolute path to lustre mount point (as listed in /proc/mounts or /etc/mtab)");

my $lfs_cmd = shift or error_exit_usage("Must specify quota, setquota, or find as third argument", "GENERAL");
$lfs_cmd =~ m/^(quota|setquota|find|[-]\S+)$/ or error_exit_usage("Unrecognized command: $lfs_cmd");

my @lfs_args;  #DELETEME

if ($lfs_cmd eq "quota") {
    # quota: Display disk usage and limits.
    my @users;
    my @groups;
    # columns to include in output (e.g. for tsv_custom format)
    my @columns;
    my $size_units;
    my $inode_units;
    my $time_units;
    # format: json, tsv, or tsv_custom (default: tsv)
    my $format = "tsv"; 
    GetOptions( "user|u=s" => \@users,
		"group|g=s" => \@groups,
		"column|c=s" => \@columns,
		"format|f=s" => \$format,
		"size-units=s" => \$size_units,
		"inode-units=s" => \$inode_units,
		"time-units=s" => \$time_units,
		"human|h" => sub {
		    if (!$size_units) {
			$size_units = "human_binary";
		    }
		    if (!$inode_units) {
			$inode_units = "human";
		    }
		    if (!$time_units) {
			$time_units = "human";
		    }
		},
		"human_decimal|d" => sub {
		    if (!$size_units) {
			$size_units = "human_decimal";
		    }
		    if (!$inode_units) {
			$inode_units = "human";
		    }
		    if (!$time_units) {
			$time_units = "human";
		    }
		},
		"help|?" => sub { exit_usage("Help for quota command:","QUOTA") },
	) or error_exit_usage("Could not parse quota options", "QUOTA");

    # set default units if unset
    if (!$size_units) {
	$size_units = "B";
    }
    if (!$inode_units) {
	$inode_units = "";
    }
    if (!$time_units) {
	$time_units = "s";
    }

    if (@users <= 0 && @groups <= 0) {
	error_exit_usage("Nothing to do for quota: please specify user(s) and/or group(s)", "QUOTA");
    }
    
    if ($format =~ m/^(json|tsv|tsv_custom)$/) {
	# get quota into hash
	my %quotas;
	foreach my $user (@users) {
	    $quotas{user}{$user} = get_quota($lustre_filesystem, "user", $user);
	}
	foreach my $group (@groups) {
	    $quotas{group}{$group} = get_quota($lustre_filesystem, "group", $group);
	}
	$quotas{group}{"testquota"} = test_quota();

	print_quotas(\%quotas, $format, $size_units, $inode_units, $time_units, \@columns);
    } else {
	error_exit_usage("Unsupported format $format", "QUOTA");
    }
} elsif ($lfs_cmd eq "setquota") {
    my $force_size_hardlimit = 0;
    my $force_size_softlimit = 0;
    my $force_inode_hardlimit = 0;
    my $force_inode_softlimit = 0;

    push @lfs_args, "setquota";

    my $uorg = shift or error_exit_usage("Must specify one of -u|--user|-g|--group as first argument after setquota");
    $uorg =~ m/^(-u|--user|-g|--group)$/ or error_exit_usage("First argument must be one of -u|--user|-g|--group");
    $uorg = $1;
    $uorg =~ s/^--user$/-u/;
    $uorg =~ s/^--group$/-g/;
    
    my $userorgroup = shift or error_exit_usage("$uorg must be followed by <uname>|<uid>|<gname>|<gid>");
    $userorgroup =~ m/^([0-9]+|[a-z_][a-z0-9_-]{0,31})$/ or error_exit("$uorg must be followed by valid <uname>|<uid>|<gname>|<gid> ($userorgroup not valid)");
    $userorgroup = $1;
    
    push @lfs_args, $uorg, $userorgroup;
    
    my $arg = shift;
    my %newquota;
    while (defined($arg)) {
	if ($arg =~ m/^(-b|--size-softlimit)$/) {
	    my $bsl = shift;
	    defined($bsl) or error_exit_usage("Must specify size-softlimit after [-b|--size-softlimit]");
	    $bsl =~ m/^([0-9.]+[bkmgtp]?)$/ or error_exit("size-softlimit $bsl not valid");
	    $bsl = $1;
	    push @lfs_args, "--size-softlimit", $bsl;
	    $newquota{"size-softlimit"} = $bsl;
	} elsif ($arg =~ m/^(-B|--size-hardlimit)$/) {
	    my $bhl = shift;
	    defined($bhl) or error_exit_usage("Must specify size-hardlimit after [-B|--size-hardlimit]");
	    $bhl =~ m/^([0-9.]+[bkmgtp]?)$/ or error_exit("size-hardlimit $bhl not valid");
	    $bhl = $1;
	    push @lfs_args, "--size-hardlimit", $bhl;
	    $newquota{"size-hardlimit"} = $bhl;
	} elsif ($arg =~ m/^(-i|--inode-softlimit)$/) {
	    my $isl = shift;
	    defined($isl) or error_exit_usage("Must specify inode-softlimit after [-i|--inode-softlimit]");
	    $isl =~ m/^([0-9.]+)$/ or error_exit("inode-softlimit $isl not valid");
	    $isl = $1;
	    push @lfs_args, "--inode-softlimit", $isl;
	    $newquota{"inode-softlimit"} = $isl;
	} elsif ($arg =~ m/^(-I|--inode-hardlimit)$/) {
	    my $ihl = shift;
	    defined($ihl) or error_exit_usage("Must specify inode-hardlimit after [-I|--inode-hardlimit]");
	    $ihl =~ m/^([0-9.]+)$/ or error_exit("inode-hardlimit $ihl not valid");
	    $ihl = $1;
	    push @lfs_args, "--inode-hardlimit", $ihl;
	    $newquota{"inode-hardlimit"} = $ihl;
	} elsif ($arg =~ m/^(--force-size-hardlimit)$/) {
	    $force_size_hardlimit = 1;
	} elsif ($arg =~ m/^(--force-size-softlimit)$/) {
	    $force_size_softlimit = 1;
	} elsif ($arg =~ m/^(--force-inode-hardlimit)$/) {
	    $force_inode_hardlimit = 1;
	} elsif ($arg =~ m/^(--force-inode-softlimit)$/) {
	    $force_inode_softlimit = 1;
	} else {
	    error_exit_usage("unrecognised setquota argument $arg");
	}
	$arg = shift;
    }
    if (@lfs_args <= 3) {
	error_exit("no limits specified, nothing to do.");
    }
    push @lfs_args, $lustre_filesystem;
    
    # always check quota before setting and report old quota to user
    my %existingquota = get_quota($lustre_filesystem, $uorg, $userorgroup);
#          'size-grace' => '-',
#          'size-hardlimit' => 'none',
#          'inode-softlimit' => 'none',
#          'size-used' => '2734402884',
#          'inode-hardlimit' => 'none',
#          'inode-grace' => 'none',
#          'size-softlimit' => 'none',
#          'inode-used' => '135738'

    # check proposed quotas against existing usage
    if ( !$force_size_hardlimit &&
	 !over_quota($existingquota{"size-hardlimit"}, $existingquota{"size-used"}) &&
	 over_quota($newquota{"size-hardlimit"}, $existingquota{"size-used"}) ) {
	error_exit("change would put size-hardlimit over quota, refusing without --force-size-hardlimit");
    }

    if ( !$force_size_softlimit &&
	 !over_quota($existingquota{"size-softlimit"}, $existingquota{"size-used"}) &&
	 over_quota($newquota{"size-softlimit"}, $existingquota{"size-used"}) ) {
	error_exit("change would put size-softlimit over quota, refusing without --force-size-softlimit");
    }

    if ( !$force_inode_hardlimit &&
	 !over_quota($existingquota{"inode-hardlimit"}, $existingquota{"inode-used"}) &&
	 over_quota($newquota{"inode-hardlimit"}, $existingquota{"inode-used"}) ) {
	error_exit("change would put inode-hardlimit over quota, refusing without --force-inode-hardlimit");
    }

    if ( !$force_inode_softlimit &&
	 !over_quota($existingquota{"inode-softlimit"}, $existingquota{"inode-used"}) &&
	 over_quota($newquota{"inode-softlimit"}, $existingquota{"inode-used"}) ) {
	error_exit("change would put inode-softlimit over quota, refusing without --force-inode-softlimit");
    }
    
} elsif ($lfs_cmd eq "find") {
    push @lfs_args, "find";
    my $matchpat = 0;

    # stat the mount point to get the dev_t for the filesystem (to check each <dir|file> entry against)
    (my $fs_dev, undef) = stat $lustre_filesystem or error_exit("could not stat mount point $lustre_filesystem");
    
    # the first arguments (until the first ! or -) must start with $lustre_filesystem
    while (!$matchpat) {
	my $dirorfile = shift;
	if (!defined($dirorfile) || $dirorfile =~ m/^[-!]/) {
	    # have an argument staring with '!' or '-' (or no argument)
	    $matchpat = 1;
	    unshift @ARGV, $dirorfile;
	} else {
            $dirorfile =~ m/^($lustre_filesystem.*)$/ or error_exit("<dir|file> $dirorfile must begin with $lustre_filesystem");
	    $dirorfile = $1;
	    # -f and -d will follow symlinks (as does `lfs find`)
	    ( -f $dirorfile || -d $dirorfile ) or error_exit("$dirorfile is not a plain file or directory");
	    # stat also follows symlinks, so in case of symlinks it is the target stats that we will get
	    (my $dirorfile_dev, undef) = stat $dirorfile or error_exit("could not stat <dir|file> $dirorfile");
	    ($dirorfile_dev == $fs_dev) or error_exit("$dirorfile and $lustre_filesystem are not on the same device ($dirorfile is on device $dirorfile_dev but $lustre_filesystem is on device $fs_dev)");
	    push @lfs_args, $dirorfile;
	}
    } 
    (@lfs_args > 0) or error_exit("must specify <dir|file> before match paramters");
    # now we should be in match parameters section 
    my $arg = shift;
    while (defined($arg)) {
	if ($arg =~ m/^[!]$/) {
	    push @lfs_args, '!';
	} elsif ($arg =~ m/^(--{0,1}[a-zA-Z]{1,})$/) {
	    $arg = $1;
	    if ($arg =~ m/^(--print0{0,1}|-[pP])$/) {
		# have one of the args that does not require a parameter
		push @lfs_args, $arg;
	    } else {
		# option requires a parameter
		my $param = shift;
		# check param syntax depending on value of arg
		if ($arg =~ m/^-(-(atime|mtime|ctime)|[AMC])$/) {
		    # [+-]N
		    $param =~ m/^([-+]{0,1}[0-9]+)$/ or error_exit("parameter after $arg was not [+-]N ($param)");
		    $param = $1;
		} elsif ($arg =~ m/^-(-(maxdepth)|[D])$/) {
		    # N
		    $param =~ m/^([0-9]+)$/ or error_exit("parameter after $arg was not numeric ($param)");
		    $param = $1;
		} elsif ($arg =~ m/^-(-(size)|[s])$/) {
		    # [+-]N[bkMGTP]
		    $param =~ m/^([-+]{0,1}[0-9]+[bkMGTP]{0,1})$/ or error_exit("parameter after $arg was not [+-]N[bkMGTP] ($param)");
		    $param = $1;
		} elsif ($arg =~ m/^-(-(name)|[n])$/) {
		    # <pattern>
		    $param =~ m/^([^\/]+)$/ or error_exit("parameter after $arg contained a '/' ($param)");
		    $param = $1;
		} elsif ($arg =~ m/^-(-(obd)|[O])$/) {
		    # <uuid[s]>
		    $param =~ m/^([-_,[:alnum:]]+)$/ or error_exit("parameter after $arg was not <uuid[s]> ($param)");
		    $param = $1;
		} elsif ($arg =~ m/^-(-(type)|[t])$/) {
		    # <filetype> == [bcdpflsD]
		    $param =~ m/^([bcdpflsD])$/ or error_exit("parameter after $arg was not [bcdpflsD] ($param)");
		    $param = $1;
		} elsif ($arg =~ m/^-(-(uid|user|gid|group)|[uUgG])$/) {
		    # <gid>|<gname>|<uid>|<uname>
		    $param =~ m/^([0-9]+|[a-z_][a-z0-9_-]{0,15})$/ or error_exit("parameter after $arg was not <gid>|<gname>|<uid>|<uname> ($param)");
		    $param = $1;
		} else {
		    error_exit("unsupported find argument $arg");
		}
		push @lfs_args, $arg;
		push @lfs_args, $param;
	    }
	} else {
	    error_exit("invalid find argument $arg");
	}
	$arg = shift;
    }
} else {
    # did not specify command, check for generic options
    unshift @ARGV, $lfs_cmd;
    my $help = 0;
    GetOptions( 'help|h|?' => \$help ) or error_exit_usage("could not process generic options");
    if ($help) {
	pod2usage({
	    -noperldoc => 1,
	    -verbose => 2,
	    -message => "Displaying full help:\n",
	    -exitval => 0,
	    -output => ">&STDOUT",
		  });
    }
}

sub exec_lfs {
    my @lfs_args = @_;

    # completely squash environment before exec
    %ENV = ();

    # call exec and never return (unless command is not found)
    exec { $lfs_bin } $lfs_bin, @lfs_args or error_exit("couldn't exec $lfs_bin");
}

# returns quota data as a hashref
# units are in bytes (not blocks or kB), inodes, and seconds
sub get_quota {
    my $filesystem = shift;
    my $quota_type = shift; # "user" or "group"
    my $quota_name = shift; # user or group name

    # validate arguments and untaint
    valid_path($filesystem) or error_exit("get_quota: filesystem $filesystem not valid");
    $filesystem =~ m/^(\/.*)$/;
    $filesystem = $1;
    $quota_name =~ m/^([0-9]+|[a-z_][a-z0-9_-]{0,31})$/ or error_exit("user/group name $quota_name not valid");
    $quota_name = $1;
    
    # this code adapted from "safe pipe open for reading" 
    # described in: http://perldoc.perl.org/perlipc.html#Safe-Pipe-Opens
    my $pid = open(CHILD_STDOUT, "-|");
    defined($pid) or error_exit("can't fork: $!");
    
    if (!$pid) { # $pid is only set in parent
	# child, call exec and never return (exec_lfs will exit on error)
	if ($quota_type eq "user") {
	    exec_lfs("quota", "-u", $quota_name, $filesystem);
	} elsif ($quota_type eq "group") {
	    exec_lfs("quota", "-g", $quota_name, $filesystem);
	} else {
	    error_exit("unexpected value for quota type: $quota_type");
	}
	# as a safety precaution, force child to exit (this should never be reached)
	error_exit("child process attempted to continue after exec_lfs");
    } else { 
        # parent, process data from child
	my %quota;
	$quota{"filesystem"} = $filesystem;
	$quota{"type"} = $quota_type;
	$quota{"name"} = $quota_name;
	
	my $usergroupline = <CHILD_STDOUT>;
	chomp $usergroupline;
	my $usergroupname = "";
	my $ugid = -1;
	if ($quota_type eq 'user') {
	    $usergroupline =~ m/user\s(\S+)/ or error_exit("could not find user in lfs quota output");
	    $usergroupname = $1;
	    $usergroupline =~ m/uid\s([0-9]+)/ or error_exit("could not find uid in lfs quota output");
	    $ugid = $1;
	} elsif ($quota_type eq 'group') {
	    $usergroupline =~ m/group\s(\S+)/ or error_exit("could not find group in lfs quota output");
	    $usergroupname = $1;
	    $usergroupline =~ m/gid\s([0-9]+)/ or error_exit("could not find gid in lfs quota output");
	    $ugid = $1;
	} else {
	    error_exit("invalid quota_type $quota_type in quotacheck");
	}

	my $headerline = <CHILD_STDOUT>;
	chomp $headerline;
	$headerline =~ m/kbytes\s+quota\s+limit\s+grace\s+files\s+quota\s+limit\s+grace\s*$/ or error_exit("unexpected header in output from lfs quota");

	my $fsline = <CHILD_STDOUT>;
	chomp $fsline;
	$fsline =~ m/^\s*$filesystem\s*$/ or error_exit("unexpected filesystem reported from lfs quota: $fsline (expecting: $filesystem)");

	my $quotaline = <CHILD_STDOUT>;
	chomp $quotaline;
	$quotaline =~ m/([0-9-]+)([*]?) # $1, $2 - size used in blocks followed by '*' if over quota
                        \s+             
                        ([0-9-]+|$LFS_QUOTA_SIZE_UNLIMITED)       # $3 - size soft limit in blocks
                        \s+
                        ([0-9-]+)       # $4 - size hard limit in blocks
                        \s+
                        (\S+|$LFS_GRACE_INACTIVE)           # $5 - block grace time remaining
                        \s+
                        ([0-9-]+)([*]?) # $6, $7 - inodes used followed by '*' if over quota
                        \s+
                        ([0-9-]+)       # $8 - inode soft limit
                        \s+
                        ([0-9-]+)       # $9 - inode hard limit
                        \s+
                        (\S+|$LFS_GRACE_INACTIVE)           # $10 - inode grace time remaining
                        \s*
                        $/x or error_exit("unexpected data in output from lfs quota: $quotaline");
	# post-process into standard units (bytes, inodes, seconds)
	$quota{"size-used"} = lfs_blocks_to_bytes($1);
	$quota{"size-overquota"} = $2;
	$quota{"size-softlimit"} = lfs_blocks_to_bytes(lfs_process_block_limit($3));
	$quota{"size-hardlimit"} = lfs_blocks_to_bytes(lfs_process_block_limit($4));
	$quota{"size-grace"} = lfs_grace_to_seconds(lfs_process_grace_time($5));
	$quota{"inode-used"} = $6; 
	$quota{"inode-overquota"} = $7;
	$quota{"inode-softlimit"} = lfs_process_inode_limit($8);
	$quota{"inode-hardlimit"} = lfs_process_inode_limit($9);
	$quota{"inode-grace"} = lfs_grace_to_seconds(lfs_process_grace_time($10));
	
	# record timestamp along with the data
	$quota{"timestamp"} = DateTime->now()->iso8601();
	
	# shouldn't be any more output - if there is, signal an error
	while(my $emptyline = <CHILD_STDOUT>) {
	    chomp $emptyline;
	    $emptyline =~ m/^\s*$/ or error_exit("unexpected additional output from lfs quota: $emptyline");
	}
	
	close(CHILD_STDOUT) or error_exit("child process exited: $!");

	return \%quota;
    }

    # this point should not be reached
    error_exit("unexpected error in get_quota");
}

sub print_quotas {
    my $quotas = shift;
    my $format = shift || "tsv";
    my $size_units = shift; 
    my $inode_units = shift; 
    my $time_units = shift; 
    my $columns = shift;

    my $unitquotas;
    foreach my $type (keys %{$quotas}) {
	foreach my $name (keys %{$quotas->{$type}}) {
	    my $quota = $quotas->{$type}->{$name};
	    error_exit("print_quotas: type did not match for $type/$name") unless $quota->{"type"} eq $type;
	    error_exit("print_quotas: name did not match for $type/$name") unless $quota->{"name"} eq $name;
	    foreach my $key (keys %{$quota}) {
		if ($key =~ m/^size-(used|softlimit|hardlimit)$/ && $quota->{$key} =~ m/^[0-9]+$/) {
		    $unitquotas->{$type}{$name}{$key} = convert_bytes($quota->{$key}, $size_units);
		} elsif ($key =~ m/^inode-(used|softlimit|hardlimit)$/ && $quota->{$key} =~ m/^[0-9]+$/) {
		    $unitquotas->{$type}{$name}{$key} = convert_inodes($quota->{$key}, $inode_units);
		} elsif ($key =~ m/-grace$/ && $quota->{$key} =~ m/^[0-9]+$/) {
		    $unitquotas->{$type}{$name}{$key} = convert_seconds($quota->{$key}, $time_units);
		} else {
		    $unitquotas->{$type}{$name}{$key} = $quota->{$key};
		}
	    }
	}
    }
    
    if (lc($format) eq 'json') {
	if (@{$columns} > 0) {
	    warn "WARNING: columns were specified on the command-line, but 'json' format does not support custom columns\n";
	}
	print_quotas_json($unitquotas);
    } elsif (lc($format) eq 'tsv') {
	if (@{$columns} > 0) {
	    warn "WARNING: columns were specified on the command-line, but 'tsv' format does not support custom columns\n";
	}
	print_quotas_tsv($unitquotas, $COLUMN_ORDER);
    } elsif (lc($format) eq 'tsv_custom') {
	# also requires $columns
	if (@{$columns} > 0) {
	    print_quotas_tsv($unitquotas, $columns);
	} else {
	    error_exit("tsv_custom requires --column options");
	}
    } else {
	error_exit("unsupported output format $format");
    }
}

sub print_quotas_json {
    my $quotas = shift;
    print JSON::XS->new->pretty(1)->encode($quotas)."\n";
}

sub print_quotas_tsv {
    my $quotas = shift;
    my $columns = shift;

    print join("\t",@{$columns})."\n";
    foreach my $type (keys %{$quotas}) {
	foreach my $name (keys %{$quotas->{$type}}) {
	    my $quota = $quotas->{$type}->{$name};
	    error_exit("print_quotas: type did not match for $type/$name") unless $quota->{"type"} eq $type;
	    error_exit("print_quotas: name did not match for $type/$name") unless $quota->{"name"} eq $name;
	    print join("\t", map {$quota->{$_}} @{$columns})."\n";
	}
    }
}

sub human_bytes_format {
    my $bytes = shift;
    my $decimal = shift;
    
    my $base = 1024;
    my @labels = @{$BINARY_UNIT_LABELS};
    if($decimal) {
	$base = 1000;
	@labels = @{$DECIMAL_UNIT_LABELS};
    }
    
    my $unit_index = 0;
    TESTUNIT: while($unit_index < $#labels) { # only need to test n-1 as we'll stay in the final unit
	my $unitmax = ($base ** ($unit_index+1)) * $HUMAN_TRIGGER_RATIO;
	if ($bytes < $unitmax) {
	    # we fit in this one, stop here
	    last TESTUNIT;
	}
	$unit_index++;
    }
    
    return sprintf("%.1f%s%s", $bytes / ($base ** $unit_index), $OUTPUT_UNIT_SEP, $labels[$unit_index]);
}

sub human_inode_format {
    my $count = shift;
    
    my $base = 1000;
    my @labels = @{$DECIMAL_PREFIXES};
    
    my $unit_index = 0;
    TESTUNIT: while($unit_index < $#labels) { # only need to test n-1 as we'll stay in the final unit
	my $unitmax = ($base ** ($unit_index+1)) * $HUMAN_TRIGGER_RATIO;
	if ($count < $unitmax) {
	    # we fit in this one, stop here
	    last TESTUNIT;
	}
	$unit_index++;
    }
    
    return sprintf("%.1f%s%s", $count / ($base ** $unit_index), $OUTPUT_UNIT_SEP, $labels[$unit_index]);
}

sub human_time_format {
    my $seconds = shift;
    
    my $result = "";
    my $remaining = $seconds;
    # convert to ywdhms format (only including the largest non-zero)
    for (my $i=@{$TIME_UNIT_RATIOS}-1; $i>0; $i--) {
	if ( ($seconds / $TIME_UNIT_RATIOS->[$i]) > 1) {
	    # include the i-th part in output
	    my $part = int($remaining / $TIME_UNIT_RATIOS->[$i]);
	    $result .= $part.$TIME_UNIT_LABELS->[$i];
	    $remaining -= $part * $TIME_UNIT_RATIOS->[$i];
	}
    }
    # add in the remaining seconds (0th unit)
    $result .= $remaining.$TIME_UNIT_LABELS->[0];

    return $result;
}

sub valid_lustre_filesystem {
    my $lustre_filesystem = shift;
    my $validated_filesystem = undef;

    if ( valid_path($lustre_filesystem) ) {
	# have valid path based on regex, check for it in /proc/mounts or /etc/mtab
	my $mfile = "/proc/mounts";
	if (! open MOUNTS, "<$mfile" ) {
	    $mfile = "/etc/mtab";
	    open MOUNTS, "<$mfile" or error_exit("could not open /proc/mounts or /etc/mtab for reading");
	}
	MOUNTLINE: while( my $mountline = <MOUNTS> ) {
	    chomp $mountline;
	    my ($spec, $mountpoint, $type, undef) = split /\s+/, $mountline, 4;
	    if ($mountpoint eq $lustre_filesystem) {
		if ($type eq "lustre") {
		    # validated, untaint
		    $mountpoint =~ m/^(\/.*)$/ or error_exit("did not have absolute path as mount point: $mountpoint");
		    $validated_filesystem = $1;
		    last MOUNTLINE;
		} else {
		    error_exit("$lustre_filesystem was listed in $mfile but was not of type lustre");
		}
	    }
	}
	close MOUNTS;
    }
    return $validated_filesystem;
}


sub valid_path {
    my $filepath = shift;
    $filepath !~ /$ILLEGAL_PATH_REGEX/ ? 1 : undef;
}


sub over_quota {
    my $quota = shift || $NO_QUOTA;
    my $used = shift or error_exit("over_quota called without used value");

    $quota =~ m/^($NO_QUOTA|[0-9]+)$/ or error_exit("quota [$quota] was neither $NO_QUOTA nor an integer");

    if (($quota eq $NO_QUOTA) ||
	($quota >= $used)) {
	# not over quota
	return undef;
    } 
    
    # over quota
    return 1;
}

sub error_exit {
    my $message = shift;
    die "Error: $message\n";
}

sub error_exit_usage {
    my $message = shift;
    my $command = shift || "";
    
    my $sections = [ qw(SYNOPSIS ARGUMENTS OPTIONS) ];
    if ($command ne "") {
	$sections = [ "$command/SYNOPSIS", "$command/ARGUMENTS", "$command/OPTIONS" ];
    }
    
    pod2usage({
	-noperldoc => 1,
	-message => "Error: $message\n",
	-exitval => 1,
	-output => ">&STDERR",
	-verbose => 99,
	-sections => $sections,
	      });

    # this should not be reached, but call it in case something goes wrong with pod2usage
    error_exit($message);
}

sub exit_usage {
    my $message = shift;
    my $command = shift || "";
    
    my $sections = [ qw(SYNOPSIS ARGUMENTS OPTIONS) ];
    if ($command ne "") {
	$sections = [ "$command/SYNOPSIS", "$command/ARGUMENTS", "$command/OPTIONS" ];
    }
    
    pod2usage({
	-noperldoc => 1,
	-message => "$message\n",
	-exitval => 0,
	-output => ">&STDOUT",
	-verbose => 99,
	-sections => $sections,
	      });

    # this should not be reached, but call it in case something goes wrong with pod2usage
    error_exit($message);
}

sub lfs_process_block_limit {
    my $blocks = shift;
    
    if ($blocks =~ m/^$LFS_QUOTA_SIZE_UNLIMITED$/) {
	return $NO_QUOTA;
    } else {
	return $blocks;
    }
}

sub lfs_process_inode_limit {
    my $inode_count = shift;
    
    if ($inode_count =~ m/^$LFS_QUOTA_INODE_UNLIMITED$/) {
        return $NO_QUOTA;
    } else {
	return $inode_count;
    }
}

sub lfs_process_grace_time {
    my $gracetime = shift;
    
    if ($gracetime =~ m/^$LFS_GRACE_INACTIVE$/) {
	return $TIMER_INACTIVE;
    } else {
	return $gracetime;
    }
}

sub lfs_blocks_to_bytes {
    my $blocks = shift;
    my $bytes = 0;
    
    if ($blocks =~ m/^$NO_QUOTA$/) {
	$bytes = $NO_QUOTA;
    } else {
	$bytes = $blocks * $LFS_BLOCKSIZE;
    }
    
    return $bytes;
}

sub lfs_grace_to_seconds {
    my $gracetime = shift;
    my $seconds = 0;
    
    # gracetime can be in seconds already or can be something like: "6d23h59m50s"
    if ($gracetime =~ m/^$TIMER_INACTIVE$/) {
	$seconds = $TIMER_INACTIVE;
    } elsif ($gracetime =~ m/[dhms]/) {
	# process in d h m s format
	$gracetime =~ m/^([0-9]*)d?([0-9]*)h?([0-9]*)m?([0-9]*)s?/ or error_exit("lfs_process_grace_to_seconds: could not process gracetime: $gracetime");
    } elsif ($gracetime =~ m/^[0-9]+$/) {
	# process as s
	$seconds = $gracetime;
    }
    return $seconds;
}

sub convert_bytes {
    my $bytes = shift;
    my $units = shift;
    if ($units) {
	if ($units eq 'human_binary') {
	    return human_bytes_format($bytes, 0);
	} elsif ($units eq 'human_decimal') {
	    return human_bytes_format($bytes, 1);
	} elsif ($units eq 'B') {
	    return $bytes.$OUTPUT_UNIT_SEP."B";
	} elsif ($units ne 'B') {
	    # fixed unit specification requiring conversion
	    for (my $i=1; $i<@{$BINARY_UNIT_LABELS}; $i++) {
		if ($BINARY_UNIT_LABELS->[$i] eq $units) {
		    return sprintf("%.1f%s%s", ($bytes / (1024 ** $i)), $OUTPUT_UNIT_SEP, $units);
		}
		if ($DECIMAL_UNIT_LABELS->[$i] eq $units) {
		    return sprintf("%.1f%s%s", ($bytes / (1000 ** $i)), $OUTPUT_UNIT_SEP, $units);
		}
	    }
	}
	error_exit("unknown size units [$units]. specify one of: ".join(', ', @{$BINARY_UNIT_LABELS}, @{$DECIMAL_UNIT_LABELS}, 'human_binary', 'human_decimal'));
    }
    error_exit("convert_bytes called without units specified");
}

sub convert_inodes {
    my $inodes = shift;
    my $units = shift;
    if ($units) {
	if ($units eq 'human') {
	    return human_inode_format($inodes);
	} else {
	    # fixed unit specification
	    for (my $i=1; $i<@{$DECIMAL_PREFIXES}; $i++) {
		if ($DECIMAL_PREFIXES->[$i] eq $units) { 
		    return sprintf("%.1f%s%s", ($inodes / (1024 ** $i)), $OUTPUT_UNIT_SEP, $units);
		}
	    }
	}
	error_exit("unknown inode units [$units]. specify one of: ".join(', ', @{$DECIMAL_PREFIXES}, 'human'));
    } else {
	return $inodes;
    }
} 

sub convert_seconds {
    my $gracetime = shift;
    my $units = shift;
    if ($units) {
	if ($units eq 'human') {
	    return human_time_format($gracetime);
	} elsif ($units eq 's') {
	    return $gracetime.$OUTPUT_UNIT_SEP."s";
	} else {
	    # fixed unit specification
	    for (my $i=1; $i<@{$TIME_UNIT_LABELS}; $i++) {
		if ($TIME_UNIT_LABELS->[$i] eq $units) {
		    return sprintf("%.1f%s%s", ($gracetime / $TIME_UNIT_RATIOS->[$i]), $OUTPUT_UNIT_SEP, $units);
		}
	    }
	}
	error_exit("unknown gracetime units [$units]. specify one of: ".join(', ', @{$TIME_UNIT_LABELS}, 'human'));
    } 
    error_exit("convert_seconds called without units specified");
}

__END__

=head1 DESCRIPTION

A wrapper script for portions of the I<lfs> command distributed with the
Lustre filesystem (L<http://lustre.org/>). Currently wraps up the functionality
of the quota, setquota, and find commands.

It takes as its first argument the mount point of a Lustre filesystem and
will only allow lfs commands to run against that filesystem. It is intended
with use along with sudo, as the sudoers file can specify that individual
users or groups can run this wrapper script against a limited set of Lustre
filesystems specifically listed.


=head1 CONFIGURATION AND ENVIRONMENT

This script is intended to be called using sudo, so for security reasons it 
does not have any external configuration files or environment variables.

In fact, it does not allow dependencies to be loaded from F<.> or from a 
PERL5LIB directory, and when calling lfs it eliminates all environment 
variables. 

You can configure Lustre operators to be able to run this command as root by 
adding an appropriate line to the F</etc/sudoers> file listing the full path 
to this script followed by the mount point of the Lustre file system for 
which they are allowed to run it.

For example:
C<user1 ALL = (root) NOPASSWD : /usr/local/bin/lustre_operator /usr/bin/lfs /mnt/lustre1, \
                              /usr/local/bin/lustre_operator /usr/bin/lfs /mnt/lustre2>


=head1 DEPENDENCIES

=over 

=item Lustre I<lfs> command 

=item L<Getopt::Long> (from CPAN)

=item L<Pod::Usage> (from CPAN)

=back


=head1 INCOMPATIBILITIES

May not work with older versions of the lfs command (Lustre < 1.8), as
this has not been tested. 


=head1 BUGS AND LIMITATIONS

There are no known bugs in this program. 

Please report problems to L<mailto:hgi@sanger.ac.uk>

Patches are welcome. 


=head1 AUTHOR

Joshua C. Randall (jcrandall@alum.mit.edu)


=head1 LICENCE AND COPYRIGHT

Copyright (c) 2013 Genome Research Ltd.

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along with
this program. If not, see <http://www.gnu.org/licenses/>.

=cut







